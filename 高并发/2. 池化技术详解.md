# 目录

- [Part 1: 数据库连接池](#part-1-数据库连接池)
  - [1. 为什么需要数据库连接池？](#1-为什么需要数据库连接池)
  - [2. Spring Boot 现在用什么连接池？默认还是 C3P0 吗？](#2-spring-boot-现在用什么连接池默认还是-c3p0-吗)
  - [3. 连接池如何保证连接是可用的？(以 HikariCP 为例)](#3-连接池如何保证连接是可用的以-hikaricp-为例)
- [Part 2: 线程池](#part-2-线程池)
  - [1. JDK 原生线程池：ThreadPoolExecutor 详解](#1-jdk-原生线程池threadpoolexecutor-详解)
  - [2. Tomcat 线程池 vs JDK 线程池](#2-tomcat-线程池-vs-jdk-线程池)
  - [3. Spring Boot 用的是什么线程池？](#3-spring-boot-用的是什么线程池)
  - [4. Spring 的 `ThreadPoolTaskExecutor`](#4-spring-的-threadpooltaskexecutor)
  - [5. 线程池使用避坑指南](#5-线程池使用避坑指南)

---

# 高并发核心技术：池化思想（数据库连接池与线程池）

“池化技术”是后端开发，尤其是高并发系统设计中，第一个必须要理解和掌握的核心思想。它的本质非常简单：**用空间换时间**。

对于那些创建成本高、消耗资源大的对象（比如数据库连接、线程），我们不是在每次需要时都去新建一个，用完就销毁；而是预先创建好一批，放在一个“池子”里。谁需要用，就从池子里借一个；用完了，再还回池子里，而不是销毁。

这种做法带来了巨大的好处：
*   **性能提升**：避免了频繁创建和销毁对象带来的开销，显著降低了系统响应时间。
*   **资源复用**：池中的对象可以被反复使用，大大提高了资源的利用率。
*   **统一管理**：可以对池中的资源进行集中管理、监控和调优，比如限制最大资源数，防止资源被耗尽。

当然，它也有一些微不足道的“缺点”，比如会额外占用一些内存来维护池，并且可能会增加系统启动时间。但在高并发场景下，这些优点远大于缺点。

下面，我们深入探讨两种最核心的池化技术：数据库连接池和线程池。

---

## Part 1: 数据库连接池

### 1. 为什么需要数据库连接池？

一个数据库连接的建立过程，涉及到 TCP 的三次握手、数据库服务端的身份认证等多个网络来回，这个过程通常需要消耗几毫秒甚至更多的时间。

*   **在低并发下**：单次 SQL 执行可能也就 1ms，建立连接耗时 4ms。总耗时 5ms，虽然连接耗时占大头，但用户几乎无感。
*   **在高并发下**：假设 QPS 是 1000，如果每次都新建连接，那么仅建立连接这一项，每秒就要消耗 `1000 * 4ms = 4s`，这是完全无法接受的。

因此，使用连接池预先建立好一批连接，让业务代码直接复用，是解决这个问题的唯一途径。

### 2. Spring Boot 现在用什么连接池？默认还是 C3P0 吗？

**早已不是 C3P0 了。**

在 Spring Boot 2.0 版本之后，默认的数据库连接池已经从 Tomcat JDBC Pool 更换为了 **HikariCP**。

HikariCP 号称是“史上最快的连接池”，它在性能、可靠性和简洁性上都远超 C3P0、DBCP、Tomcat Pool 等前辈。所以，现在如果你使用 Spring Boot 并引入 `spring-boot-starter-data-jpa` 或 `spring-boot-starter-jdbc` 依赖，你将自动获得并使用 HikariCP。

### 3. 连接池如何保证连接是可用的？(以 HikariCP 为例)

数据库连接可能会因为多种原因失效，比如：
*   数据库服务重启。
*   网络防火墙断开了空闲连接。
*   MySQL server 主动断开了空闲超过 `wait_timeout` 时长的连接。

如果连接池把一个“已断开”的连接交给应用程序，程序就会报错。为了避免这种情况，连接池必须有**连接活性检测 (Health Check)** 机制。

HikariCP 提供了几种高效的检测方式，核心思想是“**快、准、狠**”：

*   **`connection-test-query`**：这是一种传统的检测方式，配置一个简单的SQL（如 `SELECT 1`）。在从池中取出连接或还回连接时执行它，如果SQL能成功执行，说明连接有效。**但 HikariCP 官方强烈不推荐这种方式**，因为它有性能开销。
*   **`keepalive-time`**：这是 HikariCP 推荐的方式之一。它会在连接空闲超过这个设定的毫秒数时，主动发起一次“心跳”检测（ping），以防止连接被网络设备“踢掉”。这是一种在后台进行的、低开销的保活机制。
*   **`socketTimeout` 检测 (JDBC4 推荐方式)**：对于支持 JDBC4 的驱动（绝大部分现代驱动都支持），HikariCP 会利用驱动本身提供的 `isValid()` 方法来检测。这个方法通常比执行一个查询要快得多，因为它是在 TCP/IP 层面上检查 Socket 的连通性。这是**最高效、最推荐**的方式。

在 Spring Boot 中，你可以在 `application.properties` 中这样配置：
```properties
# spring.datasource.hikari...

# 设置连接在池中空闲的最长时间（毫秒），超过则可能被释放。
spring.datasource.hikari.idle-timeout=600000

# 一个连接在池中允许存活的最长时间（毫秒），到期后会被移除。
spring.datasource.hikari.max-lifetime=1800000

# 连接测试查询，非必须，除非驱动不支持isValid()
# spring.datasource.hikari.connection-test-query=SELECT 1
```
通常，你只需要配置 `idle-timeout` 和 `max-lifetime` 即可，HikariCP 会智能地选择最佳的检测方式。

---

## Part 2: 线程池

线程的创建和销毁同样是昂贵的系统调用。在高并发场景下，如果为每一个请求都创建一个新线程，系统很快就会因为资源耗尽而崩溃。线程池因此而生。

### 1. JDK 原生线程池：ThreadPoolExecutor 详解

`java.util.concurrent.ThreadPoolExecutor` 是 Java 中最核心的线程池实现。理解它的构造函数和执行流程至关重要。

#### 构造函数核心参数：
```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) { ... }
```
*   `corePoolSize` (**核心线程数**)：按摩店平时开着的按摩椅数量。即使没有客人，这些线程也保持存活，随时准备接客。
*   `maximumPoolSize` (**最大线程数**)：店里总共的按摩椅数量。当客人太多，队伍也排满了，可以临时再加开的椅子。
*   `keepAliveTime` & `unit` (**存活时间**)：当线程数超过 `corePoolSize` 时，这些“临时工”线程在空闲了指定时间后会被销- 毁，以节省资源。
*   `workQueue` (**工作队列**)：当核心线程都在忙时，新来的任务会在这里排队。队列的类型（有界/无界）是关键。
*   `handler` (**拒绝策略**)：当线程数达到最大，队列也满了，新来的任务就会被拒绝。拒绝策略定义了如何“拒绝”。

#### 执行流程（JDK 默认策略）：
1.  一个新任务来了，判断当前线程数是否小于 `corePoolSize`？
    *   **是**：直接创建一个**新线程**来执行任务（即使有其他核心线程是空闲的）。
    *   **否**：进入下一步。
2.  判断工作队列 `workQueue` 是否已满？
    *   **否**：将任务放入**队列**中等待。
    *   **是**：进入下一步。
3.  判断当前线程数是否小于 `maximumPoolSize`？
    *   **是**：创建一个**新的非核心线程**来执行这个任务。
    *   **否**：说明线程和队列都满了，执行**拒绝策略** (`handler`)。

**关键点**：JDK 的 `ThreadPoolExecutor` **优先把任务放入队列**，而不是创建更多线程。这种设计更适用于 **CPU 密集型** 任务，<mark>因为这类任务会长时间占用 CPU，过多的线程切换反而会降低性能</mark>。

### 2. Tomcat 线程池 vs JDK 线程池

Web 服务器处理的绝大多数是 **IO 密集型** 任务（如读写数据库、调用外部API）。在等待 IO 时，CPU 是空闲的。为了最大化吞吐量，我们希望 CPU 空闲时，能有其他线程顶上，而不是让任务在队列里干等。

因此，Tomcat 对 JDK 线程池的执行流程做了修改：

**Tomcat 线程池执行流程：**
1.  一个新任务来了，判断当前线程数是否小于 `corePoolSize`？
    *   **是**：创建一个**新线程**执行。
    *   **否**：进入下一步。
2.  判断当前线程数是否小于 `maximumPoolSize`？ (**与JDK不同**)
    *   **是**：**优先创建新线程**，直到达到 `maximumPoolSize`。
    *   **否**：进入下一步。
3.  判断工作队列 `workQueue` 是否已满？
    *   **否**：将任务放入**队列**。
    *   **是**：执行**拒绝策略**。

**核心区别**：Tomcat 线程池会**优先创建线程直到 `maximumPoolSize`，然后才开始让任务入队**。这种“尽力服务”的策略更适合 IO 密集型场景，能更快地响应请求，提高系统的吞- 吐量。

> #### 拓展阅读：Tomcat 是如何实现“优先创建线程”的？
>
> Tomcat 并非完全从零开始实现线程池，它巧妙地继承并改造了 JDK 的 `ThreadPoolExecutor`。
>
> 实现这一策略的关键在于，Tomcat 为线程池提供了一个**自定义的任务队列（`BlockingQueue`）**。这个队列（在 Tomcat 中名为 `TaskQueue`）在任务入队时（`offer` 方法）做了特殊处理：
>
> 1.  在 `offer` 任务时，它会先判断线程池的当前线程数是否已经达到 `maximumPoolSize`。
> 2.  如果**没有**达到，它会直接返回 `false`，**假装队列已满**。
> 3.  `ThreadPoolExecutor` 接收到 `false` 的返回值后，就会认为入队失败，从而触发下一步逻辑——创建新线程。
> 4.  只有当线程数已经**等于** `maximumPoolSize` 时，它才会真正地允许任务进入队列等待。
>
> 简单来说，就是通过一个“会说谎”的任务队列，迫使 `ThreadPoolExecutor` 改变了其默认的工作流程，从而实现了优先扩容线程的策略，使其更适合处理 Web 请求。

### 3. Spring Boot 用的是什么线程池？

这个问题需要分场景看：

*   **处理 HTTP 请求**：如果你的 Spring Boot 应用是一个 Web 应用（内嵌了 Tomcat、Jetty 或 Undertow），那么处理所有进来的 HTTP 请求的线程池，就是由 **Web 服务器提供**的。默认情况下，就是我们上面讲的 **Tomcat 改造过的线程池**。
*   **执行异步任务 (`@Async`)**：当你使用 `@Async` 注解或者 `TaskExecutor` 来执行异步任务时，Spring Boot 会使用一个**应用级的线程池**。这个线程池默认由 `ThreadPoolTaskExecutor` 创建，它的行为更接近于 JDK 原生的 `ThreadPoolExecutor`。

### 4. Spring 的 `ThreadPoolTaskExecutor`

`ThreadPoolTaskExecutor` 是 Spring 框架对 `ThreadPoolExecutor` 的一个封装，让我们可以在 Spring 环境中（比如 `application.properties` 或 Java Config）更方便地配置和管理线程池。

它的核心参数与 `ThreadPoolExecutor` 一一对应，但名字更符合 JavaBean 规范：
*   `core-pool-size`
*   `max-pool-size`
*   `keep-alive-seconds`
*   `queue-capacity` (用来创建有界队列)

在 `application.properties` 中可以这样配置默认的异步任务线程池：
```properties
spring.task.execution.pool.core-size=8
spring.task.execution.pool.max-size=16
spring.task.execution.pool.queue-capacity=100
spring.task.execution.pool.keep-alive=60s
spring.task.execution.thread-name-prefix=my-async-
```

### 5. 线程池使用避坑指南

1.  **坚决不要用无界队列**：像 `Executors.newFixedThreadPool()` 内部使用的是 `LinkedBlockingQueue`，如果不指定容量，它就是无界的。这会导致任务无限堆积，最终耗尽内存导致 OOM (Out of Memory)。**必须为队列设置容量！**
2.  **监控队列堆积**：线程池的任务队列长度是一个非常重要的监控指标。如果队列持续处于高水位，说明任务处理不过来了，需要考虑是增加线程数，还是优化任务本身。
3.  **自定义线程工厂 (`ThreadFactory`)**：为线程池里的线程起一个有意义的名字（比如 `database-sync-thread-`），这样在排查问题（如打印线程堆栈）时，能一眼看出这个线程是干什么的。
4.  **选择合适的拒绝策略**：默认的 `AbortPolicy` 会直接抛异常。有时 `CallerRunsPolicy`（让提交任务的线程自己去执行）或者自定义的拒绝策略（如记录日志、写入MQ稍后重试）会是更好的选择。
