# Redis 核心数据结构与底层实现

**目录**

- [1. 整体概览](#1-整体概览)
- [2. 底层数据结构探秘](#2-底层数据结构探秘)
- [3. 五种基本数据类型详解](#3-五种基本数据类型详解)
  - [String (字符串)](#string-字符串)
  - [List (列表)](#list-列表)
  - [Hash (哈希)](#hash-哈希)
  - [Set (集合)](#set-集合)
  - [Zset (Sorted Set, 有序集合)](#zset-sorted-set-有序集合)
- [4. 总结](#4-总结)

## 1. 整体概览

Redis 是一个高性能的键值（Key-Value）数据库，其丰富多样的数据类型是其核心特性之一。我们通常说的 5 种基本数据类型——String、List、Hash、Set、Zset，是 Redis 直接暴露给用户使用的，代表了数据的逻辑结构。

然而，为了在性能和内存效率之间达到极致的平衡，Redis 的底层实现远比这复杂。这 5 种数据类型的背后，是由 **8 种** 核心的数据结构来支撑的。Redis 会根据存储数据的大小和类型，智能地选择最高效的底层数据结构。

这 5 种基本数据类型与底层数据结构的对应关系如下：

| 数据类型 | 底层数据结构 (Redis 7.0 及以后) | 历史版本说明 |
| :--- | :--- | :--- |
| **String** | `SDS` (简单动态字符串) | 一直是 SDS，针对不同长度有 `raw`, `embstr` 等优化。|
| **List** | `QuickList` (快速列表) | Redis 3.2 之前是 `LinkedList` 或 `ZipList`。|
| **Hash** | `ListPack` (紧凑列表) 或 `Dict` (哈希表) | Redis 7.0 之前是 `ZipList` 或 `Dict`。|
| **Set** | `IntSet` (整数集合) 或 `Dict` (哈希表) | - |
| **Zset** | `ListPack` (紧凑列表) 或 `SkipList` + `Dict` | Redis 7.0 之前是 `ZipList` 或 `SkipList` + `Dict`。|

> **核心思想**：Redis 通过多种底层结构的组合，实现了一种“折衷”策略。例如，当数据量较小时，倾向于使用像 `ListPack`、`IntSet` 这样内存占用更低、更紧凑的数据结构；当数据量增长到一定阈值后，则自动转换为像 `Dict`、`SkipList` 这样时间复杂度更优的“标准”数据结构。

## 2. 底层数据结构探秘

要真正理解 Redis，必须先了解这些幕后的英雄。

-   **SDS (Simple Dynamic String)**
    Redis 没有直接使用 C 语言的字符串，而是自己设计了 SDS 这一数据结构来作为字符串的底层实现。它在性能、安全性和功能上都远超 C 语言的 `char*`。在 `String` 数据类型部分，我们会对其进行更详细的介绍。

-   **Dict (哈希表/字典)**
    Dict 是 Redis 实现 `Hash` 和 `Set` 的核心。它与 Java 的 `HashMap` 类似，通过数组 + 链表（解决哈希冲突）的方式实现。Dict 的一个关键特性是 **渐进式 rehash**，当哈希表需要扩容时，它不是一次性将所有键值对都迁移到新表，而是分批次进行，从而避免了单次操作耗时过长，保证了 Redis 的高性能。

-   **ListPack (紧凑列表)**
    自 Redis 7.0 起，`ListPack` 取代了 `ZipList`。它是一块连续的内存空间，用于存储小体积的 `Hash`、`List` 和 `Zset`。它解决了 `ZipList` 的一个主要缺陷——**连锁更新**。在 `ZipList` 中，修改一个节点可能导致后续所有节点的内存重分配，成本很高。而 `ListPack` 的设计避免了这个问题，使得更新操作更高效。

-   **IntSet (整数集合)**
    当一个 `Set` 只包含整数值，并且元素数量不多时，Redis 会使用 `IntSet` 来存储。它本质上是一个有序的、不重复的整数数组。因为数据有序，查找可以通过二分查找进行，速度很快。同时，它的内存占用远小于 `Dict`。

-   **SkipList (跳表)**
    `Zset` 的核心之一。跳表是一种“空间换时间”的有序数据结构，它通过在链表的基础上增加多级索引，实现了平均 O(logN) 的查找、插入、删除复杂度，效率媲美平衡树，但实现更简单。`Zset` 同时使用 `SkipList` 和 `Dict`，`SkipList` 保证了元素的有序性（按 score 排序），`Dict` 则提供了 O(1) 的方式来查找某个成员的 score 值。

-   **QuickList (快速列表)**
    自 Redis 3.2 起 `List` 类型的底层实现。`QuickList` 是一个双向链表，但它的每个节点都是一个 `ListPack`（或旧版的 `ZipList`）。这种设计结合了双向链表（插入删除方便）和 `ListPack`（空间效率高）的优点，在两端操作（LPUSH/RPOP）和内存占用上都表现出色。

## 3. 五种基本数据类型详解

### String (字符串)

#### a. 介绍
String 是 Redis 最基础的类型，是二进制安全的，可以存储任何数据，如数字、文本、JSON、甚至是图片或视频的二进制数据。其底层实现为 **SDS（Simple Dynamic String，简单动态字符串）**。

虽然 Redis 是用 C 语言编写的，但它并没有直接使用 C 语言传统的 `char*` 字符串，而是专门设计了 SDS。这是因为 C 字符串存在一系列问题，而 SDS 针对性地进行了优化。

**SDS 与 C 字符串的区别：**

1.  **O(1) 复杂度的长度获取**：
    *   **C 字符串**: 本身不记录长度，必须遍历整个字符串，直到遇到结束符 `\0`，时间复杂度为 O(N)。
    *   **SDS**: 结构内部直接包含一个 `len` 属性，用于记录字符串的实际长度。获取长度时只需读取这个属性，时间复杂度为 O(1)，这对于 `STRLEN` 这样的命令来说至关重要。

2.  **杜绝缓冲区溢出（Buffer Overflow）**：
    *   **C 字符串**: C 字符串本身不记录长度，像 `strcat` 这样的函数在执行拼接时，并不会检查目标缓冲区是否有足够的空间。它只会盲目地从目标字符串的 `\0` 结束符开始，将源字符串的所有内容复制过去。如果源字符串过长，就会超出目标缓冲区的边界，覆盖掉后续的内存，造成数据污染，甚至导致程序崩溃或被利用为安全漏洞。

        **举例说明：**
        ```c
        #include <string.h>

        void main() {
            char dest[5] = "Hi"; // 数组大小为5, 只能存放4个字符 + '\0'
            char src[] = " World!"; // 这个字符串明显放不下
            strcat(dest, src); // 这里会发生严重的缓冲区溢出
        }
        ```
        在上面的代码中，`dest` 数组后面的内存会被 `strcat` 函数无情地覆盖，这就是典型的缓冲区溢出。

    *   **SDS**: 在进行修改操作时，其 API 会先检查内部记录的可用空间 `alloc` 是否足够容纳修改后的内容。如果不够，SDS 会自动进行扩容，分配一块更大的内存空间，然后再执行修改。这从根本上杜绝了缓冲区溢出的风险。

3.  **二进制安全（Binary Safe）**：
    *   **C 字符串**: 必须以 `\0` 作为结尾，这意味着字符串中间不能包含 `\0`，否则会被提前截断。因此，C 字符串只能存储文本数据，无法安全地存储图片、音频等二进制数据。
    *   **SDS**: 通过 `len` 属性来判断字符串是否结束，而不是依赖 `\0`。这意味着 SDS 可以包含任意字符，包括 `\0`，从而能够安全地存储任何二进制数据。

4.  **高效的内存分配策略**：
    *   **C 字符串**: 每次增长或缩短，通常都需要重新分配内存，这在频繁修改的场景下性能很差。
    *   **SDS**: 采用了两种优化策略：
        *   **空间预分配**: 当 SDS 增长时，程序不仅会分配所必需的空间，还会额外分配一些未使用的空间。如果字符串长度小于 1MB，则分配加倍的空间；如果超过 1MB，则每次多分配 1MB。这减少了连续执行字符串增长操作所需的内存重分配次数。
        *   **惰性空间释放**: 当 SDS 缩短时，程序并不会立即回收多出来的字节，而是通过 `alloc` 属性记录下来，以备将来增长时使用。

综上所述，SDS 的设计完美契合了 Redis 高性能、高并发的应用场景。

下面是 C 字符串与 SDS 内存布局的简单图示，可以更直观地理解它们的区别：

**1. C 字符串 "Redis" 的内存布局：**
```text
+---+---+---+---+---+----+
| R | e | d | i | s | \0 |
+---+---+---+---+---+----+
(没有元数据，长度计算需要从头遍历到 '\0')
```

**2. SDS 字符串 "Redis" 的内存布局 (简化示例):**
```text
+--------+---------+---------------------------+
| len: 5 | alloc: 10 | R | e | d | i | s | \0 | ... |
+--------+---------+---------------------------+
    ^         ^          ^                   ^
    |         |          |                   |
  记录长度  总分配空间   实际数据         预留的空闲空间 (free = alloc - len)
(O(1)获取) (用于扩容判断)
```
在这个例子中，SDS 不仅存储了字符串 "Redis"，还额外记录了两个重要的元数据：`len`（实际长度为 5）和 `alloc`（总共分配了 10 字节的容量）。这使得 SDS 在获取长度、拼接字符串等操作上比 C 字符串高效得多。

#### b. 常用命令

| 命令 | 介绍 |
| :--- | :--- |
| `SET key value` | 设置指定 key 的值 |
| `GET key` | 获取指定 key 的值 |
| `SETNX key value` | 仅在 key 不存在时设置 |
| `MSET / MGET` | 同时设置/获取多个 key-value |
| `INCR / DECR` | 将 key 中储存的数字值增/减一 |
| `STRLEN key` | 返回字符串值的长度 |
| `SETEX key seconds value` | 设置值并指定过期时间 |
| `EXISTS key` | 判断指定 key 是否存在 |
| `DEL key` | 删除指定的 key |

#### c. 代码示例
```shell
# 基本操作
> SET user:1 "Alice"
OK
> GET user:1
"Alice"

# 计数器
> SET counter 100
OK
> INCR counter
(integer) 101
> DECR counter
(integer) 100

# 带过期的 key
> SETEX session:123 3600 "user_token_abc"
OK
> TTL session:123
(integer) 3598
```

#### d. 应用场景
1.  **缓存**：缓存用户信息、Session、页面片段等，这是最常见的应用。
2.  **计数器**：文章阅读量、点赞数、用户请求限流等。
3.  **分布式锁**：利用 `SETNX` 的原子性，可以实现简单的分布式锁。
4.  **位图 (Bitmap)**：通过 `SETBIT` 和 `GETBIT`，可以高效处理大量的布尔状态，如用户签到、在线状态统计等。

### List (列表)

#### a. 介绍
Redis 的 List 是一个有序的字符串链表。其底层实现自 Redis 3.2 后为 `QuickList`。它支持在头部（左）和尾部（右）进行快速的压入/弹出操作，因此可以作为栈或队列使用。

##### 深入 QuickList：链表与紧凑列表的结合
你可能会问，既然 `LSET` 这样的命令按索引访问用数组更快，为什么 Redis 不用数组？这是因为 List 的核心场景是作为队列和栈，两端（`LPUSH/RPUSH`）的插入和删除操作必须是 O(1) 的。如果用数组，在头部插入元素会导致所有后续元素移动，变成 O(N) 操作，这在数据量大时是不可接受的。

为了兼顾两端操作性能、内存效率和索引性能，Redis 设计了 `QuickList` 这一混合数据结构。<mark>**`QuickList` 本质上是一个双向链表，但它的每个节点都是一个 `ListPack`（紧凑列表）**</mark>。

下面是 `QuickList` 的结构示意图：
```text
           Node 1                  Node 2                  Node 3
  [ A, B, C ]   <======>   [ D, E, F ]   <======>   [ G, H, I ]
(是一个ListPack)           (是一个ListPack)           (是一个ListPack)
```

- **QuickList (外层)**: 这是一个标准的双向链表，提供了 O(1) 复杂度的在头尾添加和删除节点的能力。
- **ListPack (内层节点)**: 自 Redis 7.0 起，`ListPack` 取代了 `ZipList`。它是一块**连续的内存**，用于存储一定数量的元素。它极其节省内存，因为它不像普通对象那样有额外的元数据开销。在一个节点内部查找、插入元素的效率很高。

这种设计的精妙之处在于：
1.  **极高的两端操作效率**: 对于 `LPUSH` 或 `RPUSH`，大部分情况下只是在头部或尾部节点的 `ListPack` 中添加元素，这个操作非常快。只有当一个 `ListPack` 满了，才需要创建一个新的链表节点，复杂度依然接近 O(1)。
2.  **极高的内存效率**: 多个元素被打包存放在一个 `ListPack` 中，大大减少了链表指针（每个节点需要 `prev` 和 `next` 两个指针）的内存开销，提升了内存利用率。
3.  **避免了数组的 O(N) 插入/删除**: 它完美避开了在数组头部插入元素导致大规模数据移动的问题。
4.  **优化了索引访问**: 虽然 `LRANGE` 或 `LSET` 宏观上仍需遍历链表节点，但节点数量远少于元素总数，所以它的实际性能比纯链表要好得多。

综上，`QuickList` 是一个为了平衡核心需求（高性能队列/栈）和次要需求（内存效率、索引访问）而做出的非常经典且高效的数据结构设计。

#### b. 常用命令

| 命令 | 介绍 |
| :--- | :--- |
| `LPUSH / RPUSH key value...` | 从列表左/右侧插入一个或多个元素 |
| `LPOP / RPOP key` | 从列表左/右侧弹出一个元素 |
| `BLPOP / BRPOP key timeout` | `LPOP`/`RPOP` 的阻塞版本，列表为空时等待 |
| `LRANGE key start end` | 获取指定范围内的元素（`0 -1` 代表所有） |
| `LLEN key` | 获取列表长度 |
| `LSET key index value` | 通过索引设置元素的值 |

#### c. 代码示例
```shell
# 作为队列 (FIFO: First In First Out)
> LPUSH tasks "task1" "task2" "task3"
(integer) 3
> RPOP tasks
"task1"
> RPOP tasks
"task2"

# 作为栈 (LIFO: Last In First Out)
> RPUSH stack "a" "b" "c"
(integer) 3
> RPOP stack
"c"
```

#### d. 应用场景
1.  **消息队列**：利用 `LPUSH` 和 `BRPOP` 可以实现一个简单的生产者-消费者消息队列。
2.  **时间线 (Timeline)**：微博/朋友圈的关注人动态，新的动态通过 `LPUSH` 插入，通过 `LRANGE` 分页展示。
3.  **最新列表**：例如网站首页展示的最新发布的 10 篇文章。

### Hash (哈希)

#### a. 介绍
Hash 是一个键值对集合，非常适合用来存储对象。它将一个对象的多个字段映射到一个 Redis key 中。当 Hash 中元素较少且值较短时，底层使用 `ListPack` 存储，非常节省内存；否则，使用 `Dict`。

##### 深入理解 Hash 的底层实现

**1. Dict（哈希表）结构示意图**

Redis 的 Dict 采用**拉链法**解决哈希冲突，与 Java 的 HashMap 实现方式类似：

```text
哈希表结构 (Dict):
┌─────────────────────────────────────────────────────────────┐
│ 哈希表 (ht[0])                                               │
├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
│[0]  │[1]  │[2]  │[3]  │[4]  │[5]  │[6]  │[7]  │[8]  │[9]  │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│ NULL│     │     │     │     │     │     │     │     │     │
│     │     │     │     │     │     │     │     │     │     │
│     │     │     │     │     │     │     │     │     │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
       │
       ▼
   ┌─────────┐    ┌─────────┐    ┌─────────┐
   │ key1    │───▶│ key2    │───▶│ key3    │
   │ value1  │    │ value2  │    │ value3  │
   └─────────┘    └─────────┘    └─────────┘
   (哈希冲突的链表)
```

**关键特性与动态行为：**

- **数组 + 链表**: 哈希表是一个数组，每个位置存储一个链表头指针。
- **哈希冲突处理**: 当多个 key 哈希到同一位置时，通过链表连接。

- **初始大小与扩容机制**:
  - **初始大小**: Redis 的哈希表初始大小为 **4**。它遵循极致的内存效率原则，只有在第一个元素添加时才创建，并从最小尺寸开始。
  - **负载因子 (Load Factor)**: `已用节点数 / 哈希表总大小`。
  - **扩容时机**:
    - **通常情况**: 当**负载因子 ≥ 1**时，触发扩容。
    - **特殊情况 (持久化期间)**: 如果 Redis 正在执行 `BGSAVE` 或 `BGREWRITEAOF`，条件会变得更苛刻，需要当**负载因子 ≥ 5**时才触发。这是为了避免在子进程持久化时，父进程的扩容操作因**写时复制 (Copy-on-Write)** 产生大量内存开销。
  - **缩容时机**: 当元素被大量删除后，若**负载因子 < 0.1**，会触发缩容以回收空间。

- **渐进式 rehash (Progressive Rehash)**:
  这是 Redis 避免性能抖动的核心机制，与 Java HashMap 的一次性扩容截然不同。其精髓在于**化整为零**，将繁重的迁移工作分摊到成百上千次操作中。
  
  **过程详解：**
  1.  **准备阶段**: 满足扩容条件后，分配一个更大的新哈希表 `ht[1]`（通常是 `ht[0].used * 2` 以上的第一个 2 的 n 次幂），此时数据仍在旧表 `ht[0]`。
  2.  **迁移阶段 (双表共存)**:
      - **写操作**: 新增的键值对会直接写入新表 `ht[1]`。
      - **读/删/更操作**: 会先查询旧表 `ht[0]`，如果不存在，再查询新表 `ht[1]`。
      - **核心步骤**: **每次**对该 Hash 进行操作时（增删改查），都会“顺便”将 `ht[0]` 中的一小部分数据迁移到 `ht[1]`。
  3.  **后台任务**: 为了防止哈希表在 rehash 期间因没有操作而导致迁移停滞，Redis 的后台定时任务也会辅助进行少量的迁移工作。
  4.  **完成阶段**: 当 `ht[0]` 中所有数据都迁移到 `ht[1]` 后，释放 `ht[0]` 的空间，并将 `ht[1]` 设置为 `ht[0]`，rehash 过程正式结束。
  
  通过这种方式，Redis 保证了即使在处理包含数百万键的巨大哈希表时，扩容操作也不会导致服务出现可感知的延迟。

**2. 为什么小数据用 ListPack，大数据用 Dict？**

这是一个经典的**空间与时间权衡**问题：

**ListPack 的优势（小数据场景）：**
```text
ListPack 内存布局：
┌─────────────────────────────────────────────────┐
│ [field1][value1][field2][value2][field3][value3] │
└─────────────────────────────────────────────────┘
(连续内存，无指针开销)
```

- **内存效率极高**：连续存储，无指针开销，无哈希表元数据
- **缓存友好**：数据紧凑，CPU 缓存命中率高
- **适合小数据**：当字段数量少、值较短时，ListPack 的内存占用远小于 Dict

**Dict 的优势（大数据场景）：**
```text
Dict 查找过程：
1. hash(key) → 数组索引
2. 遍历链表查找匹配的 key
3. 返回对应的 value
时间复杂度：平均 O(1)，最坏 O(n)
```

- **查找效率高**：平均 O(1) 的查找复杂度
- **支持动态扩容**：可以处理大量数据
- **支持复杂操作**：如范围查询、批量操作等

**转换阈值（Redis 7.0）：**
- **ListPack → Dict**：当 Hash 中字段数量超过 `hash-max-listpack-entries`（默认 512）或任一字段值长度超过 `hash-max-listpack-value`（默认 64 字节）时
- **Dict → ListPack**：当 Dict 收缩到很小时，会考虑转换回 ListPack

**实际例子：**
```shell
# 小数据：使用 ListPack
> HSET user:1 name "Bob" age "30" city "Beijing"
# 内存布局：[name][Bob][age][30][city][Beijing]

# 大数据：使用 Dict  
> HSET user:1 name "Bob" age "30" city "Beijing" 
> HSET user:1 hobby1 "reading" hobby2 "swimming" ... hobby100 "coding"
# 转换为 Dict，使用哈希表存储
```

#### b. 常用命令

| 命令 | 介绍 |
| :--- | :--- |
| `HSET key field value` | 设置哈希表字段的值 |
| `HGET key field` | 获取哈希表字段的值 |
| `HMSET / HMGET` | 同时设置/获取多个字段 |
| `HGETALL key` | 获取所有字段和值 |
| `HDEL key field...` | 删除一个或多个字段 |
| `HLEN key` | 获取字段数量 |
| `HINCRBY key field increment` | 为字段的整数值增加指定增量 |

#### c. 代码示例
```shell
# 存储用户信息
> HSET user:1 name "Bob" age 30 email "bob@example.com"
(integer) 3
> HGET user:1 name
"Bob"
> HGETALL user:1
1) "name"
2) "Bob"
3) "age"
4) "30"
5) "email"
6) "bob@example.com"

> HINCRBY user:1 age 1
(integer) 31
```

#### d. 应用场景
-   **对象缓存**：缓存用户信息、商品信息、文章详情等。相比于将对象每个字段都用一个 String 存储，Hash 结构更清晰，管理更方便，且在数据量小时内存效率更高。

### Set (集合)

#### a. 介绍
Set 是一个无序、唯一的字符串集合。当集合中全是整数且数量不多时，底层用 `IntSet`；否则用 `Dict`。Set 提供了丰富的集合运算功能，如交集、并集、差集。

##### 深入理解 Set 的底层实现

**1. IntSet（整数集合）结构示意图**

当 Set 中只包含整数且数量较少时，Redis 使用 IntSet 来存储，这是一个**有序的整数数组**：

```text
IntSet 内存布局：
┌─────────────────────────────────────────────────┐
│ encoding: INTSET_ENC_INT16 (2字节整数)           │
├─────────────────────────────────────────────────┤
│ length: 5 (元素个数)                             │
├─────────────────────────────────────────────────┤
│ contents: [1, 3, 5, 7, 9] (有序数组)             │
└─────────────────────────────────────────────────┘
```

**IntSet 的关键特性：**
- **有序存储**：数组中的整数按升序排列
- **动态编码**：根据数值范围自动选择编码方式
  - `INTSET_ENC_INT16`：16位整数（-32768 到 32767）
  - `INTSET_ENC_INT32`：32位整数（-2147483648 到 2147483647）
  - `INTSET_ENC_INT64`：64位整数
- **二分查找**：利用有序特性，查找时间复杂度为 O(log n)

**2. IntSet 的编码升级机制**

当插入的整数超出当前编码范围时，IntSet 会自动升级编码：

```text
初始状态 (INTSET_ENC_INT16):
┌─────────────────────────────────────────────────┐
│ encoding: INTSET_ENC_INT16                      │
│ length: 3                                        │
│ contents: [1, 3, 5] (每个元素占2字节)            │
└─────────────────────────────────────────────────┘

插入 32768 (超出16位范围) 后升级为 INTSET_ENC_INT32:
┌─────────────────────────────────────────────────┐
│ encoding: INTSET_ENC_INT32                      │
│ length: 4                                        │
│ contents: [1, 3, 5, 32768] (每个元素占4字节)     │
└─────────────────────────────────────────────────┘
```

**3. 为什么小整数用 IntSet，大数据用 Dict？**

**IntSet 的优势（小整数场景）：**
```text
IntSet 内存占用：
- 元数据：encoding(4字节) + length(4字节) = 8字节
- 数据：n个整数 × 编码大小
- 总计：8 + n × encoding_size

Dict 内存占用：
- 哈希表元数据：数组 + 链表指针
- 每个元素：key对象 + value对象 + 链表节点
- 总计：远大于 IntSet
```

- **内存效率极高**：连续存储，无指针开销
- **查找效率高**：二分查找 O(log n)，对小数据集足够快
- **缓存友好**：连续内存访问

**Dict 的优势（大数据场景）：**
- **查找效率**：平均 O(1) 的哈希查找
- **支持任意类型**：不仅限于整数
- **动态扩容**：可以处理大量数据

**转换阈值：**
- **IntSet → Dict**：当集合中元素数量超过 `set-max-intset-entries`（默认 512）或包含非整数元素时
- **Dict → IntSet**：当 Dict 收缩且所有元素都是整数时，会考虑转换回 IntSet

**4. 实际例子对比**

```shell
# 小整数集合：使用 IntSet
> SADD numbers 1 3 5 7 9
# 内存布局：[encoding][length][1,3,5,7,9]

# 大整数集合：使用 Dict
> SADD numbers 1 2 3 ... 1000
# 转换为 Dict，使用哈希表存储

# 包含字符串：使用 Dict
> SADD users "alice" "bob" "charlie"
# 必须使用 Dict，因为 IntSet 只支持整数
```

**5. IntSet 的查找过程**

```text
查找元素 5：
1. 检查 encoding 是否支持该数值
2. 使用二分查找在有序数组中搜索
3. 找到返回 true，否则返回 false

二分查找过程：
[1, 3, 5, 7, 9]
 ↑     ↑     ↑
left  mid  right
     5 == 5 ✓ 找到！
```

#### b. 常用命令

| 命令 | 介绍 |
| :--- | :--- |
| `SADD key member...` | 向集合添加一个或多个成员 |
| `SREM key member...` | 移除一个或多个成员 |
| `SISMEMBER key member` | 判断成员是否在集合中 |
| `SMEMBERS key` | 返回集合中的所有成员 |
| `SCARD key` | 获取集合的成员数 |
| `SINTER / SUNION / SDIFF` | 求交集/并集/差集 |
| `SPOP key [count]` | 随机弹出一个或多个成员 |

#### c. 代码示例
```shell
> SADD user:1:following "user:2" "user:3" "user:4"
(integer) 3
> SADD user:2:following "user:3" "user:5"
(integer) 2

# user:1 和 user:2 的共同关注
> SINTER user:1:following user:2:following
1) "user:3"

# user:1 可能感兴趣的人 (关注了 user:2 但没关注 user:1)
> SDIFF user:2:following user:1:following
1) "user:5"
```

#### d. 应用场景
1.  **标签系统**：给一篇文章或一个用户打上多个标签。
2.  **社交网络**：共同关注、共同好友、可能认识的人等。
3.  **去重统计**：例如统计每日访问网站的独立 IP 地址（UV）。
4.  **抽奖**：使用 `SPOP` 或 `SRANDMEMBER` 可以方便地实现抽奖功能。

### Zset (Sorted Set, 有序集合)

#### a. 介绍
Zset 和 Set 一样，也是唯一的字符串集合，但每个成员都会关联一个 `score` (浮点数)。Redis 会根据 `score` 对成员进行排序。当元素数量较少且值较短时，其底层实现是 `ListPack`；否则，它是一个 `SkipList` 和一个 `Dict` 的组合，`SkipList` 保证了有序性，`Dict` 保证了 O(1) 的成员查找。

#### b. 常用命令

| 命令 | 介绍 |
| :--- | :--- |
| `ZADD key score member...` | 添加或更新一个或多个成员及其 score |
| `ZREM key member...` | 移除一个或多个成员 |
| `ZRANGE / ZREVRANGE key start stop [WITHSCORES]` | 按 score 升序/降序返回指定排名范围的成员 |
| `ZRANGEBYSCORE key min max` | 按 score 返回指定分数范围的成员 |
| `ZCARD key` | 获取成员数量 |
| `ZSCORE key member` | 获取成员的 score |
| `ZRANK / ZREVRANK key member` | 获取成员的升序/降序排名 |

#### c. 代码示例
```shell
# 游戏积分排行榜
> ZADD leaderboard 1500 "player1" 2300 "player2" 980 "player3"
(integer) 3

# 获取积分最高的 Top 2 玩家
> ZREVRANGE leaderboard 0 1 WITHSCORES
1) "player2"
2) "2300"
3) "player1"
4) "1500"

# 获取 player3 的排名
> ZRANK leaderboard "player3"
(integer) 0
```

#### d. 应用场景
-   **排行榜**：任何需要排序的场景，如积分榜、销售榜、热搜榜。
-   **带权重的任务队列**：可以根据任务的优先级（score）来处理任务。
-   **范围查找**：例如查找薪资在某个区间的员工。

## 4. 总结

| 数据类型 | 一句话描述 | 典型应用场景 |
| :--- | :--- | :--- |
| **String** | 可存万物的基础二进制安全字符串 | 缓存、计数器、分布式锁、位图 |
| **List** | 有序的、可重复的字符串链表 | 消息队列、时间线、最新列表 |
| **Hash** | 适合存储对象的键值对集合 | 对象缓存（用户、商品信息） |
| **Set** | 无序的、唯一的字符串集合 | 标签、社交关系、去重统计、抽奖 |
| **Zset** | 有序的、带权重的唯一字符串集合 | 排行榜、优先级队列、范围查询 |
