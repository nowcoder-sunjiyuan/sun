# Redis 分布式锁详解

## 1. 什么是分布式锁？

在单体应用中，我们通常使用语言或框架提供的锁机制（如 Java 的 `synchronized` 或 `ReentrantLock`）来解决并发问题，确保共享资源在多线程环境下的访问安全。然而，在分布式系统中，应用部署在多台独立的机器上，内存级的锁无法跨越进程和机器的边界。

**分布式锁** 是一种跨机器的、全局性的同步机制，它用于协调不同节点（机器或进程）对共享资源的访问，确保在任何时刻，只有一个客户端能够持有锁，从而访问该共享资源。

## 2. 为什么需要分布式锁？（应用场景）

分布式锁的核心目的是保证**幂等性**和**数据一致性**。当多个服务实例需要协同操作同一个资源时，就需要分布式锁。

典型场景包括：

-   **防止重复处理**：例如，一个订单支付成功后，需要调用发货服务。为防止因网络重试等原因导致重复发货，可以在发货操作前获取该订单的分布式锁。
-   **保护共享资源**：例如，多个服务实例都需要修改同一个配置文件或更新同一个数据库记录。
-   **任务调度**：在分布式定时任务中，确保某个任务在集群中只被一个节点执行。
-   **避免缓存击穿**：当缓存失效时，多个请求同时涌入，都去查询数据库。可以使用分布式锁，只让一个请求去查询数据库并回填缓存，其他请求等待。

## 3. 如何用 Redis 实现分布式锁？

Redis 因其高性能、单线程执行命令的特性，成为实现分布式锁的常用工具。下面我们逐步演进一个可靠的 Redis 分布式锁。

### 方案一：SETNX + EXPIRE (错误示范)

最直观的想法是使用 `SETNX` (SET if Not eXists) 命令。如果 key 不存在，则设置成功，代表获取锁；如果 key 已存在，则设置失败，代表锁已被持有。为了防止死锁，再用 `EXPIRE` 设置一个过期时间。

```bash
# 获取锁
SETNX lock_key "some_value"
# 如果 SETNX 返回 1 (成功)
EXPIRE lock_key 30
```

**问题所在**：`SETNX` 和 `EXPIRE` 是两个独立的命令，**不具备原子性**。如果在执行完 `SETNX` 后，客户端崩溃或服务重启，`EXPIRE` 命令没有被执行，这个锁就会变成一个**永不释放的死锁**。

### 方案二：SET 指令的原子操作 (推荐)

从 Redis 2.6.12 版本开始，`SET` 命令扩展了参数，可以原子性地完成 `SETNX` 和 `EXPIRE` 的功能。

```bash
# 获取锁 (NX: 不存在时设置, PX: 过期时间单位为毫秒)
SET lock_key "unique_request_id" NX PX 30000
```

-   **`lock_key`**: 锁的唯一标识。
-   **`unique_request_id`**: 一个唯一的值，用于标识加锁的客户端。**这是安全释放锁的关键**。
-   **`NX`**: 表示只有当 `lock_key` 不存在时，才设置该 key。这等同于 `SETNX`。
-   **`PX 30000`**: 表示这个锁的过期时间是 30000 毫秒（30 秒）。

**这样就保证了加锁和设置过期时间是原子操作，解决了死锁问题。**

### 方案三：Lua 脚本保证原子性（释放锁）

释放锁的操作不能简单地用 `DEL` 命令。考虑以下场景：

1.  客户端 A 获取了锁，但由于业务执行时间过长，锁自动过期了。
2.  客户端 B 此时获取了同一个锁。
3.  客户端 A 执行完毕，执行 `DEL` 命令，结果**错误地释放了客户端 B 的锁**。

为了安全地释放锁，必须确保“**谁加的锁，谁才能解**”。这就是为什么我们在加锁时需要一个 `unique_request_id`。

释放锁的逻辑应该是：`获取锁的值` -> `判断是否与自己的标识相等` -> `如果相等，则删除`。这个过程也必须是**原子**的，否则在 `GET` 和 `DEL` 之间，锁可能过期，然后被其他客户端获取。

我们可以使用 **Lua 脚本**来保证这个过程的原子性，因为 Redis 会以原子方式执行整个 Lua 脚本。

```lua
-- a safe way to release a lock
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```
- `KEYS[1]` 是 `lock_key`。
- `ARGV[1]` 是 `unique_request_id`。

在代码中，通过 `EVAL` 命令执行此脚本。

### Redlock 算法

上述方案在单机 Redis 环境下已经相当可靠。但在主从复制或哨兵模式下，仍然存在风险：

1.  客户端 A 在 Master 节点获取了锁。
2.  Master 节点在将锁信息同步给 Slave 之前宕机了。
3.  Slave 节点被提升为新的 Master。
4.  客户端 B 可以在新的 Master 上再次获取同一个锁，导致两个客户端同时持有锁。

为了解决这个问题，Redis 的作者提出了 **Redlock** 算法。其核心思想是：客户端需要向 N 个独立的 Redis 实例（通常建议是 5 个）发起加锁请求，当且仅当从**多数派**（例如，`N/2 + 1`，5个实例中的3个）实例上成功获取锁，并且总耗时小于锁的有效时间，才认为加锁成功。

Redlock 算法更复杂，也引发了很多争议。在大多数场景下，基于单机 Redis 的方案已经足够，除非业务对锁的可靠性有极端的要求。

## 4. 自己设计分布式锁需要注意什么？

设计一个健壮的分布式锁，需要满足以下几个核心特性：

1.  **互斥性 (Mutual Exclusion)**
    -   在任何时刻，只有一个客户端能持有锁。这是最基本的要求。`SETNX` 或原子化的 `SET` 命令就是为了保证这一点。

2.  **防死锁 (Liveness / Deadlock Prevention)**
    -   即使持有锁的客户端崩溃或发生网络分区，锁最终也能够被释放，不会导致其他客户端永远无法获取锁。通常通过**设置过期时间**来实现。

3.  **容错性 (Fault Tolerance)**
    -   只要大部分节点正常工作，客户端就能够获取和释放锁。例如，单个 Redis 节点宕机不应该导致整个锁服务不可用。Redlock 或 Zookeeper 等方案就是为了增强容错性。

4.  **正确性 (Correctness / Safety)**
    -   解铃还须系铃人。锁的释放必须由加锁者自己完成，不能释放别人的锁。通过**为锁设置唯一标识**（如 `unique_request_id`）并在释放时校验来实现。

### 其他高级特性

-   **可重入性 (Reentrancy)**
    -   同一个线程/进程在持有锁的情况下，可以再次请求并获取同一个锁，而不会被自己阻塞。实现方式是在锁信息中记录持有者的标识和重入次数。
-   **公平性 (Fairness)**
    -   是否按照请求的顺序来获取锁。实现公平锁会带来性能开销，通常分布式锁优先保证性能，不保证公平性。

## 5. 主流分布式锁方案对比

| 特性 | Redis 分布式锁 | ZooKeeper 分布式锁 | 数据库分布式锁 |
| :--- | :--- | :--- | :--- |
| **实现复杂度** | 简单，依赖 Redis 的原子命令 | 复杂，依赖 ZK 的 API 和特性 | 简单，依赖数据库的唯一约束 |
| **性能/吞吐量** | **高**，基于内存，网络开销小 | 中等，涉及多次网络交互和磁盘 I/O | 低，依赖数据库，开销大 |
| **可靠性/一致性**| 一般（主从切换可能丢锁），Redlock 可增强 | **高**，基于 ZAB 协议，保证强一致性 | 中等，依赖数据库的可用性 |
| **可重入性** | 需自己实现 | 官方客户端支持 | 需自己实现 |
| **死锁预防** | 依赖过期时间 (TTL) | 依赖临时节点 (Ephemeral Node) | 依赖数据库事务和连接管理 |
| **适用场景** | 高并发、高性能、对一致性要求不是极端苛刻的场景 | 可靠性要求高、并发量不大的场景，如分布式协调 | 并发量小、开发简单快速的场景 |

## 6. 总结与注意事项

-   **不要把锁的过期时间设置得太短**：要确保业务逻辑在锁的过期时间内能够执行完毕，否则会出现锁提前释放，导致并发问题。可以考虑为锁增加“看门狗”(Watchdog) 机制，在业务未完成时自动续期。
-   **优先使用成熟的框架**：如 Redisson，它封装了分布式锁的复杂实现，包括可重入、自动续期（看门狗）、Redlock 等高级功能，避免自己造轮子出错。
-   **分布式锁是“防君子不防小人”的**：它是一种约定，需要所有访问共享资源的服务都遵守这个约定去获取锁，否则锁机制就形同虚设。
