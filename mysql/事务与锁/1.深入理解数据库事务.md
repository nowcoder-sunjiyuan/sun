# 1. 深入理解数据库事务

## 目录
- [一、 事务的四大特性 (ACID)](#一-事务的四大特性-acid)
- [二、 并发事务带来的四大问题](#二-并发事务带来的四大问题)
- [三、 SQL 标准的四种隔离级别](#三-sql-标准的四种隔离级别)
- [四、 深度辨析：为什么线上业务更偏爱“读已提交”？](#四-深度辨析为什么线上业务更偏爱读已提交)

## 一、 事务的四大特性 (ACID)

事务是数据库执行过程中的一个逻辑单位，它包含了一系列操作，这些操作要么全部成功执行，要么全部失败回滚。ACID是数据库事务必须遵循的四个核心特性。

-   **原子性 (Atomicity)**：事务是最小的执行单位，不可再分。事务内的所有操作要么全部完成，要么全部取消。
-   **一致性 (Consistency)**：事务的终极目标。它确保数据库从一个正确的状态迁移到另一个正确的状态，这既包括数据库自身的约束（如非空、唯一），也包括应用层定义的业务逻辑（如转账总额不变）。
-   **隔离性 (Isolation)**：并发执行的事务之间互不干扰。在事务看来，它就像是系统中唯一运行的那个事务。
-   **持久性 (Durability)**：一旦事务成功提交，其对数据库的修改就是永久性的，即使发生系统故障（如断电）也不会丢失。

> **核心关系：A (原子性)、I (隔离性)、D (持久性) 是手段，C (一致性) 是最终目的。**
> 这三大特性共同协作，就是为了保证数据状态的最终一致性。

## 二、 并发事务带来的四大问题

在并发环境下，如果不对事务进行有效隔离，可能会导致以下几种数据不一致的问题。

-   **脏读 (Dirty Read)**
    -   **场景**: 事务A修改了某条数据，但**还未提交**，此时事务B读取了这条被修改的“脏”数据。如果事务A最终回滚，那么事务B读取到的就是一条从未正式存在过的垃圾数据。

-   **丢失修改 (Lost Update)**
    -   **场景**: 事务A和事务B**同时读取**同一条数据，A先修改并提交，B后修改并提交。B的提交**覆盖**了A的提交，导致A的修改如同“丢失”了一般。

-   **不可重复读 (Non-Repeatable Read)**
    -   **场景**: 事务A**两次读取同一行数据**，在这两次读取之间，事务B**修改 (UPDATE)**了这行数据并提交。导致事务A两次读取的结果不一致。
    -   **核心**: 重点在于**“修改”**，是数据内容的变化。

-   **幻读 (Phantom Read)**
    -   **场景**: 事务A**两次执行范围查询**（例如 `SELECT ... WHERE age > 20`），在这两次查询之间，事务B**插入 (INSERT)**了一条新的、符合该范围的数据并提交。导致事务A第二次查询时，发现多出了一条“幻象”般的记录。
    -   **核心**: 重点在于**“新增”或“删除”**，是数据行数的变化。

## 三、 SQL 标准的四种隔离级别

为了解决上述并发问题，SQL标准定义了四种隔离级别，它们在数据一致性和并发性能之间做出了不同的权衡。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :--- | :--- | :--- | :--- |
| **读未提交 (READ UNCOMMITTED)** | 允许 | 允许 | 允许 |
| **读已提交 (READ COMMITTED)** | 阻止 | 允许 | 允许 |
| **可重复读 (REPEATABLE READ)** | 阻止 | 阻止 | 允许 (理论上) |
| **串行化 (SERIALIZABLE)** | 阻止 | 阻止 | 阻止 |

-   **读未提交 (READ UNCOMMITTED)**
    -   最低级别，几乎不加控制，性能最高，但数据一致性最差。实际应用中极少使用。

-   **读已提交 (READ COMMITTED)**
    -   解决了脏读问题。一个事务只能读取到其他事务**已经提交**的数据。
    -   这是 Oracle、SQL Server 等大多数商业数据库的**默认隔离级别**。

-   **可重复读 (REPEATABLE READ)**
    -   解决了不可重复读问题。在一个事务内，多次读取同一行数据，结果保证一致。
    -   这是 **MySQL InnoDB 存储引擎的默认隔离级别**。
    -   **特别注意**: InnoDB 在此级别下，通过 **MVCC (多版本并发控制)** 和 **间隙锁 (Gap Locks)** 机制，在很大程度上**解决了幻读问题**，使其隔离效果接近于串行化。

-   **串行化 (SERIALIZABLE)**
    -   最高级别，所有事务串行执行，完全避免了所有并发问题，数据一致性最好。
    -   但并发性能极差，因为不存在任何并行操作。

## 四、 深度辨析：为什么线上业务更偏爱“读已提交”？

这是一个常见的面试考点，也是实践中的重要抉择。

**结论先行**：虽然MySQL InnoDB默认是“可重复读”，但在许多高并发的互联网业务中，会主动将隔离级别调整为“读已提交”。

### 1. “可重复读”的代价：间隙锁 (Gap Locks)

-   **核心优势**: 保证了在一个事务内反复读取同一行数据时结果不变。
-   **实现代价**: 为了防止幻读，InnoDB 引入了**间隙锁**。当一个事务锁定某行或某个范围时，它不仅会锁住数据行本身，还会锁住数据行之间的“间隙”，防止其他事务在这些间隙中 `INSERT` 新数据。
-   **性能瓶颈**: 这种为防止幻读而存在的间隙锁，**极大地降低了数据库的并发写入性能**。一个事务锁定了某个范围，其他事务在范围内的写入操作都会被阻塞。

### 2. “读已提交”的优势：更高的并发

-   **工作方式**: 事务中的每一次读取，都会获取当前已提交的最新数据版本。
-   **并发优势**:
    -   **没有间隙锁**: 在“读已提交”级别下，**基本没有间隙锁**。锁定的范围更小、更精确，极大地提升了并发写入的吞-吞吐量。
    -   **死锁概率降低**: 因为锁定的范围和复杂度都下降了，事务之间互相等待造成死锁的概率也随之降低。

### 3. 务实的权衡

对于绝大多数互联网业务（如电商、社交）而言：

-   **高并发写入是刚需**: 秒杀、发帖等场景要求数据库能处理大量并发写入。
-   **“可重复读”并非刚需**: 在一个事务中两次读取库存发现不一致，在业务上通常可以接受，应用层逻辑也可以处理。

因此，线上业务选择“读已提交”，本质上是**牺牲了部分隔离性（允许不可重复读和幻读），换取了至关重要的并发性能**。
