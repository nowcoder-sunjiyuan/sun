# MySQL三大日志之Undo Log

> 在深入探讨MVCC时，我们已经接触到了Undo Log，它是实现多版本并发控制的基石。然而，Undo Log的作用并不仅限于此。本文将详细剖析Undo Log的本质、两大核心作用、内部构造及其生命周期。

<details>
<summary>目录</summary>

- [MySQL三大日志之Undo Log](#mysql三大日志之undo-log)
  - [一、 Undo Log的本质是什么？](#一-undo-log的本质是什么)
    - [逻辑日志 vs 物理日志](#逻辑日志-vs-物理日志)
    - [Undo Log是"反向操作"记录](#undo-log是反向操作记录)
  - [二、 Undo Log的两大核心作用](#二-undo-log的两大核心作用)
    - [作用一：实现事务的原子性（回滚）](#作用一实现事务的原子性回滚)
    - [作用二：实现MVCC（多版本并发控制）](#作用二实现mvcc多版本并发控制)
  - [三、 Undo Log的存储与内部结构](#三-undo-log的存储与内部结构)
    - [Undo Log的存放位置](#undo-log的存放位置)
    - [Undo Log的记录类型](#undo-log的记录类型)
  - [四、 Undo Log的生命周期：从产生到销毁](#四-undo-log的生命周期从产生到销毁)
    - [1. 事务开始](#1-事务开始)
    - [2. 执行写操作（产生Undo Log）](#2-执行写操作产生undo-log)
    - [3. 事务提交](#3-事务提交)
    - [4. Purge线程清理](#4-purge线程清理)
  - [五、 核心问题解答](#五-核心问题解答)
    - [1. Undo Log是一条记录一条记录的Log吗？](#1-undo-log是一条记录一条记录的log吗)
    - [2. Undo Log是不是只为MVCC服务？](#2-undo-log是不是只为mvcc服务)

</details>

## 一、 Undo Log的本质是什么？

### 逻辑日志 vs 物理日志

在MySQL中，日志可以分为两大类：
*   **物理日志 (Physical Log)**: 记录了数据页（Page）在物理层面的变更。比如，它会记录“在某个数据页的某个偏移量上，修改了几个字节的数据”。Redo Log就是典型的物理日志。
*   **逻辑日志 (Logical Log)**: 记录的是与物理页面无关的、逻辑上的操作。比如，它会记录“给某张表的某一行，执行了一个UPDATE操作，把字段A的值从'X'改为了'Y'”。**Undo Log**和Binlog都属于逻辑日志。

### Undo Log是"反向操作"记录

`Undo Log`的中文名是**撤销日志**，这个名字非常形象。它的核心思想是：**记录下事务对数据进行修改之前的“旧值”，或者说，记录一个能让数据“撤销”回修改前状态的操作**。

例如：
*   当你执行`INSERT`一条新记录时，Undo Log就记录一个与之相反的`DELETE`操作的信息。
*   当你执行`DELETE`一条记录时，Undo Log就记录一个`INSERT`操作的信息，把被删除的数据记下来。
*   当你执行`UPDATE`一条记录时，Undo Log就把修改前的“旧值”记录下来。

这种“反向操作”的设计，直接引出了它的两大核心作用。

## 二、 Undo Log的两大核心作用

您的理解非常接近真相，但有一个关键点需要补充。Undo Log并**不只是**为MVCC服务，它同时也是实现ACID四大特性中**原子性 (Atomicity)** 的关键保障。

### 作用一：实现事务的原子性（回滚）

事务的原子性要求“一个事务内的所有操作，要么全部成功，要么全部失败”。如果一个事务执行到一半，因为某种原因（如数据库崩溃、程序错误、用户手动ROLLBACK）需要中止，数据库必须有能力将这个事务所做过的所有修改“撤销”掉，恢复到事务开始前的状态。

这个“撤销”的能力，正是由Undo Log提供的。当需要回滚时，数据库会读取该事务对应的Undo Log链，并执行其中记录的“反向操作”，从而精准地将数据恢复到初始状态。

**所以，Undo Log的第一个、也是最基础的作用，就是支持事务回滚，保障原子性。**

### 作用二：实现MVCC（多版本并发控制）

这是我们已经详细讨论过的作用。在“读-写”并发场景下，为了实现不加锁的“快照读”，数据库需要能够为读操作提供一个历史版本的数据。

这个“历史版本”从哪里来？正是从Undo Log中来。当一个事务需要读取某行数据时，如果发现这行数据的最新版本被一个还未提交的事务所持有（通过Read View判断），它就会顺着`DB_ROLL_PTR`回滚指针，去Undo Log中寻找上一个、上上一个...直到找到一个对它可见的历史版本。

**所以，Undo Log的第二个核心作用，就是为MVCC提供历史版本数据，实现非阻塞的并发读。**

## 三、 Undo Log的存储与内部结构

### Undo Log的存放位置

Undo Log被存储在专门的**回滚段 (Rollback Segment)** 中，这些回滚段包含于系统表空间（ibdata文件）或在MySQL 5.6之后可以配置的独立undo表空间内。

### Undo Log的记录类型

根据操作的不同，Undo Log主要分为两种类型：

*   **`INSERT` Undo Log**:
    *   在`INSERT`操作中产生。
    *   由于插入的记录只对当前事务可见，对其他事务是不可见的，所以这种Undo Log**只用于事务回滚**。
    *   一旦事务提交，这条Undo Log就可以被**立即丢弃**，因为它不再有任何用处。

*   **`UPDATE` Undo Log**:
    *   在`UPDATE`或`DELETE`操作中产生。
    *   这种Undo Log**既要用于事务回滚，也要用于MVCC的快照读**。
    *   因此，即使创建它的事务已经提交，这条Undo Log也不能被立即删除。因为它可能还需要被其他正在进行的、更早开启的事务所访问（作为历史版本）。

## 四、 Undo Log的生命周期：从产生到销毁

1.  **事务开始**:
    当一个事务开始时，如果它需要执行写操作，InnoDB会为其分配一个事务ID，并准备好记录Undo Log。

2.  **执行写操作（产生Undo Log）**:
    当事务执行`INSERT`, `UPDATE`, `DELETE`时，它会首先将相应的“反向操作”或“旧值”写入Undo Log中。这个过程是**先写日志，再改数据**。

3.  **事务提交**:
    *   对于`INSERT` Undo Log，事务提交后它们会被放入一个待清理链表，并可以很快被清理。
    *   对于`UPDATE` Undo Log，事务提交后它们**不会立即被删除**，而是被放入一个特殊的“历史链表”中。因为它们仍然是数据库历史版本的一部分，可能需要被其他事务用于快照读。

4.  **Purge线程清理**:
    MySQL有一个后台的**Purge线程**，它会定期检查“历史链表”中的`UPDATE` Undo Log。如果Purge线程判断某个Undo Log所代表的历史版本，已经不再被任何现存的、活跃的事务所需要（即这个版本比所有活跃事务的Read View中的`min_trx_id`还要老），那么这个Undo Log就会被安全地、彻底地删除，从而回收存储空间。

## 五、 核心问题解答

### 1. Undo Log是一条记录一条记录的Log吗？

**是的，您的理解完全正确。**
Undo Log是逻辑日志，它的组织方式就是基于记录的。每一次对数据行的修改（INSERT, UPDATE, DELETE），都会产生一条与之对应的Undo Log记录。当同一个事务对同一行数据进行多次修改时，这些Undo Log记录会通过`DB_ROLL_PTR`指针串联起来，形成一个该行数据的“版本链”。

### 2. Undo Log是不是只为MVCC服务？

**不是，这是最容易产生的一个误区。**
如上所述，Undo Log有两大核心使命：
1.  **事务回滚 (保障原子性)**: 这是它最基本、最原始的功能。
2.  **提供历史版本 (实现MVCC)**: 这是它在并发场景下的延伸功能。

可以说，没有Undo Log，就没有事务的原子性；而在InnoDB中，正是巧妙地复用了这份用于回滚的日志，才高效地实现了MVCC机制。
