# 深入理解MySQL中的MVCC

> 事务那一张里讲了，并发事务遇到的问题，事务的隔离级别，MVCC的概念，快照读和当前读等等，这一节细致的讲一下MVCC

<details>
<summary>目录</summary>

- [深入理解MySQL中的MVCC](#深入理解mysql中的mvcc)
  - [MVCC的相关概念](#mvcc的相关概念)
    - [什么是MVCC?](#什么是mvcc)
    - [什么是当前读和快照读？](#什么是当前读和快照读)
    - [当前读，快照读和MVCC的关系](#当前读快照读和mvcc的关系)
    - [MVCC能解决什么问题，好处是？](#mvcc能解决什么问题好处是)
    - [小结一下咯](#小结一下咯)
  - [MVCC的实现原理](#mvcc的实现原理)
    - [隐式字段](#隐式字段)
    - [undo日志](#undo日志)
      - [purge](#purge)
    - [Read View(读视图)](#read-view读视图)
      - [什么是Read View?](#什么是read-view)
    - [整体流程](#整体流程)
  - [MVCC相关问题](#mvcc相关问题)
    - [RR是如何在RC级的基础上解决不可重复读的？](#rr是如何在rc级的基础上解决不可重复读的)
    - [RC,RR级别下的InnoDB快照读有什么不同？](#rcrr级别下的innodb快照读有什么不同)

</details>

## MVCC的相关概念

### 什么是MVCC?

MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

### 什么是当前读和快照读？

在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?

*   **当前读**
    像`select lock in share mode`(共享锁), `select for update` ; `update`, `insert` ,`delete`(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
*   **快照读**
    像不加锁的`select`操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。

说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。

### 当前读，快照读和MVCC的关系

*   准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念。
*   而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。
*   要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理。

### MVCC能解决什么问题，好处是？

数据库并发场景有三种，分别为：

*   **读-读**：不存在任何问题，也不需要并发控制
*   **读-写**：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
*   **写-写**：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题：

*   在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
*   同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

### 小结一下咯

总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

*   **MVCC + 悲观锁**
    MVCC解决读写冲突，悲观锁解决写写冲突
*   **MVCC + 乐观锁**
    MVCC解决读写冲突，乐观锁解决写写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题。

## MVCC的实现原理

MVCC的实现原理，初看可能觉得有些复杂，因为它涉及到几个环环相扣的概念。但我们可以把它想象成一个巧妙的“数据时空穿梭”机制。数据库里的每一行数据，不仅仅只有一个当前值，而是可能存在一个“版本链”，记录了它从诞生之初到现在的演变历史。当一个事务要去读取数据时，它会拿到一个“时空通行证”（Read View），这个通行证决定了它能看到这个演变历史中的哪个版本。

这个机制的核心由三大组件构成：
1.  **版本链 (Undo Log)**：数据的历史记录。
2.  **隐藏字段**：镶嵌在每行数据中，用于串联历史版本、标记创作者的元信息。
3.  **读视图 (Read View)**：决定事务能看到哪个版本的规则。

接下来，我们用一个具体的例子，把这三个组件串起来，看看它们是如何协同工作的。

### 1. 核心组件：隐藏字段与版本链 (Undo Log)

为了实现MVCC，InnoDB在表的每一行记录上，都悄悄加了几个隐藏字段。我们重点关注其中两个：

*   `DB_TRX_ID` (6字节): 记录了**最近一次修改**这行记录的事务ID。可以理解为，这行数据的“最后修改者”是谁。
*   `DB_ROLL_PTR` (7字节): **回滚指针**。它像一根指针，指向这行记录被修改前的“上一个版本”。这个“上一个版本”就存放在 **Undo Log**（撤销日志）里。

当一个事务修改一行数据时，发生了什么？

假设我们有一张账户表 `account`，里面有一条记录：`id=1, name='Alice', balance=100`。它的初始 `DB_TRX_ID` 可能是创建它的事务ID，比如 `9`。

```
  行记录 (当前版本)
+----+-------+---------+------------+---------------+
| id | name  | balance | DB_TRX_ID  | DB_ROLL_PTR   |
+----+-------+---------+------------+---------------+
| 1  | Alice | 100     | 9          | NULL          |
+----+-------+---------+------------+---------------+
```

现在，一个ID为 `20` 的事务（我们称之为`Trx-20`）执行了 `UPDATE account SET balance = 150 WHERE id = 1;`。

InnoDB并不会直接覆盖 `balance=100` 的老数据，而是会这样做：
1.  **加锁**：首先对这行记录加排他锁，保证同一时间只有一个事务能修改它。
2.  **记录Undo Log**：将修改前的老版本数据（`id=1, name='Alice', balance=100, DB_TRX_ID=9, ...`）完整复制一份，存入 **Undo Log** 中。这就像拍了一张快照。
3.  **修改当前行**：更新当前行记录的 `balance` 为 `150`，并将这行记录的 `DB_TRX_ID` 修改为当前事务的ID，也就是 `20`。
4.  **建立连接**：将这行记录的 `DB_ROLL_PTR` 指针，指向刚刚在 Undo Log 中创建的那个快照。

操作完成后，数据就形成了如下的“版本链”：

```
  行记录 (当前版本)
+----+-------+---------+------------+---------------+
| id | name  | balance | DB_TRX_ID  | DB_ROLL_PTR   |
+----+-------+---------+------------+---------------+
| 1  | Alice | 150     | 20         | 指向 ->       |
+----+-------+---------+------------+---------------+
                                     |
                                     |
  Undo Log (历史版本)                |
+------------------------------------+
| (这是一个指向Undo Log中记录的指针)
|
|  Undo Log 中的记录
| +----+-------+---------+------------+---------------+
| | id | name  | balance | DB_TRX_ID  | DB_ROLL_PTR   |
| +----+-------+---------+------------+---------------+
| | 1  | Alice | 100     | 9          | ...           |
| +----+-------+---------+------------+---------------+
+------------------------------------------------------+
```

如果之后又有一个事务 `Trx-33` 把 `balance` 修改为 `200`，这个链条会继续增长，`Trx-33` 修改后的当前版本会指向 `Trx-20` 修改后的版本（现在也进入了Undo Log），形成一个单向链表。

**这个由当前记录和一系列Undo Log构成的版本链，就是MVCC能够读取到历史数据的基础。**

### 2. 规则制定者：Read View (读视图)

有了数据的历史版本链还不够，还需要一个规则来告诉事务：“在这么多个版本里，你到底能看哪一个？” 这个规则的制定者，就是 **Read View**。

我们可以把 Read View 理解成一个**事务在开启时获得的“数据库状态快照”或者“可见性判断尺”**。当一个事务第一次执行查询（快照读）时，InnoDB会为它创建一个Read View。这个Read View的核心作用，就是定义了在当前事务的视角里，哪些事务的修改是“可见的”，哪些是“不可见的”。

这张“快照”并不会复制整个数据库，而是记录下那一刻几个关键的事务ID信息：

*   `creator_trx_id`: **创建者事务ID**。即创建这个Read View的事务本身的ID。我们用它来判断，如果一个数据版本的最后修改者是自己，那这个版本当然永远是对自己可见的。

*   `m_ids`: **活跃事务ID列表**。这是生成Read View时，系统中所有“活跃且未提交”的事务的ID列表。可以把它看作“正在进行中的修改者”名单。如果一个数据版本的 `DB_TRX_ID` 在这个名单里，就意味着修改这个版本的事务在我开启查询时“还没搞定”（未提交），所以它的修改对我来说是不可见的。

*   `min_trx_id`: **活跃事务的最小ID**。也就是 `m_ids` 列表中的最小值。这是一个重要的“历史分割线”。任何 `DB_TRX_ID` **小于** `min_trx_id` 的数据版本，都意味着修改它的事务在“我”开启查询之前**就已经提交了**。这些版本是确定的、固化的历史，因此对我来说是**可见的**。

*   `max_trx_id`: **预分配的下一个事务ID**。这是生成Read View时，系统准备分配给下一个新事务的ID。它代表了“未来”。任何 `DB_TRX_ID` **大于或等于** `max_trx_id` 的数据版本，都意味着修改它的事务是在“我”开启查询**之后才启动的**。这些来自未来的修改，对我来说是**不可见的**。

通过这几个属性，Read View 就构成了一个清晰的可见性判断区间：

```
<-- 已提交 (可见) -- [ min_trx_id ----- m_ids(活跃, 不可见) ----- max_trx_id ] -- 未来 (不可见) -->
```

当一个事务拿着它的Read View去读取一个数据行的版本时，它会遵循以下逻辑来判断这个版本是否可见：
1.  首先，看这个版本的 `DB_TRX_ID` 是不是 `creator_trx_id`？如果是，说明是自己改的，可见。
2.  如果不是自己，就看 `DB_TRX_ID` 是否小于 `min_trx_id`？如果是，说明是历史数据，可见。
3.  再看 `DB_TRX_ID` 是否大于或等于 `max_trx_id`？如果是，说明是未来的修改，不可见。
4.  最后，判断 `DB_TRX_ID` 是否在 `m_ids` 列表中？如果在，说明是还未提交的事务做的修改，不可见。
5.  如果都不满足以上条件（即 `DB_TRX_ID` 在 `min_trx_id` 和 `max_trx_id` 之间，且不在 `m_ids` 列表中），那就意味着修改这个版本的事务在我开启查询时**已经提交了**，所以对我来说是**可见的**。

这个判断逻辑，就是MVCC实现多版本可见性控制的核心。在下一节的完整例子中，我们将看到这个逻辑是如何被一步步应用的。

### 3. MVCC工作流程：一个完整的例子

让我们把上面的概念串联起来，看一个完整的读写冲突的例子。假设隔离级别是**可重复读 (Repeatable Read)**。

**初始状态:**
账户表里有一条记录，由 `Trx-9` 创建。
```
+----+-------+---------+------------+
| id | name  | balance | DB_TRX_ID  |
+----+-------+---------+------------+
| 1  | Alice | 100     | 9          |
+----+-------+---------+------------+
```

**时间线:**
1.  **事务A (`Trx-20`) 启动。** `BEGIN;`
2.  **事务B (`Trx-30`) 启动。** `BEGIN;`
3.  **事务A 修改数据。** `UPDATE account SET balance = 150 WHERE id = 1;`
    此时，版本链形成：
    ```
    +--------------------------------------+
    |          行记录 (当前最新版本)          |
    +--------------------------------------+
    | balance: 150                         |
    | DB_TRX_ID: 20                        |
    | DB_ROLL_PTR: 指向 Undo Log 中的记录  |
    +--------------------------------------+
                  |
                  | (DB_ROLL_PTR)
                  v
    +--------------------------------------+
    |          Undo Log (历史版本)          |
    +--------------------------------------+
    | balance: 100                         |
    | DB_TRX_ID: 9                         |
    +--------------------------------------+
    ```
4.  **事务B 读取数据。** `SELECT balance FROM account WHERE id = 1;`
    这是事务B**第一次**进行快照读，于是，就在这一刻，为事务B生成一个 **Read View**。
    *   **当时活跃的事务有哪些？** 事务A (`Trx-20`) 还没提交，事务B (`Trx-30`) 自己也算。所以 `m_ids = [20, 30]`。
    *   `min_trx_id` 是 `20`。
    *   假设当时没有更大的事务ID，那么 `max_trx_id` 就是 `31`。
    *   `creator_trx_id` 是 `30`。
    
    事务B拿着这个Read View，开始读取 `id=1` 的这行数据。它首先看到的是**当前最新版本**：`{ balance: 150, DB_TRX_ID: 20 }`。

    <mark>**可见性判断开始：**</mark>
    *   **规则1**: 检查该版本的 `DB_TRX_ID` (`20`) 是否是自己 (`creator_trx_id` 是 `30`)？不是。自己修改的自己总能看见。
    *   **规则2**: 检查 `DB_TRX_ID` (`20`) 是否小于 `min_trx_id` (`20`)？不是（20不小于20）。如果小于，说明这个版本是在Read View生成时就已经提交的事务创建的，可以看见。
    *   **规则3**: 检查 `DB_TRX_ID` (`20`) 是否大于等于 `max_trx_id` (`31`)？不是。如果大于等于，说明这个版本是在Read View生成之后才开启的事务创建的，看不见。
    *   **规则4**: 检查 `DB_TRX_ID` (`20`) 是否在 `m_ids` 列表 `[20, 30]` 中？**是的！** 这意味着，在事务B生成Read View的那一刻，修改这条记录的事务A（`Trx-20`）**还在活跃，没有提交**。因此，这个版本对事务B来说是**不可见的**。

    **寻找下一个版本：**
    既然最新版本不可见，事务B就会顺着 `DB_ROLL_PTR` 指针，找到Undo Log中的上一个版本：`{ balance: 100, DB_TRX_ID: 9 }`。

    **再次进行可见性判断：**
    *   检查该版本的 `DB_TRX_ID` (`9`)。
    *   **规则2**: 检查 `DB_TRX_ID` (`9`) 是否小于 `min_trx_id` (`20`)？**是的！** 这说明，在事务B开启时，创建这个版本的事务 `Trx-9` **早就已经提交了**。因此，这个版本对事务B来说是**可见的**。

    **结论：** 事务B最终读取到的 `balance` 是 **100**。

5.  **事务A 提交。** `COMMIT;`
6.  **事务B 再次读取数据。** `SELECT balance FROM account WHERE id = 1;`
    *   因为隔离级别是**可重复读**，事务B**不会重新生成Read View**，而是继续使用步骤4中创建的那个。
    *   它会重复一遍上面的可见性判断流程。虽然事务A此时已经提交了，但对于事务B的这张“旧照片”（Read View）来说，`Trx-20` 仍然记录在 `m_ids` 列表里。
    *   因此，判断逻辑和结果完全一样，事务B读取到的 `balance` **仍然是 100**。这就保证了**可重复读**。

### 小结与 Purge

通过这个流程，MVCC巧妙地实现了读写不阻塞。读操作通过版本链和Read View去寻找合适的历史版本，完全不需要等待写操作释放锁。

最后，<mark>Undo Log中的历史版本不会永远保留。当数据库确认一个历史版本不可能再被任何一个活跃的事务访问到时（即它比所有活跃事务的 `min_trx_id` 还要老），一个后台的 **Purge** 线程就会来把它彻底删除，以回收空间</mark>。

这就是MVCC实现原理的一个通俗化讲解。它用空间换时间，通过维护多份数据拷贝，配合一套精密的可见性判断规则，极大地提升了数据库的并发读写性能。

## MVCC相关问题

### 核心差异：Read View的创建时机 (RC vs RR)

我们已经理解了MVCC的原理，但还有一个关键问题：不同的事务隔离级别（主要是读已提交RC 和 可重复读RR）是如何影响我们读取到的数据的？

答案就在于 **Read View的创建时机**。

*   **在可重复读 (Repeatable Read, RR) 级别下**：
    一个事务的 **Read View** 在其**第一次执行快照读（`SELECT`）时被创建**，并且**在整个事务的生命周期内，都会重复使用这同一个Read View**。这就像事务在开始时拍了一张照片，之后的所有查询都以这张旧照片为准，无论其他事务做了什么修改和提交。

*   **在读已提交 (Read Committed, RC) 级别下**：
    事务中的**每一次快照读，都会重新创建一个全新的Read View**。这就像事务每次查询时，都会重新拍一张最新的照片，因此它总能看到其他事务已经提交的最新修改。

正是这个核心差异，导致了RR级别避免了“不可重复读”，而RC级别会出现。现在，我们用这个核心规则来分析您给出的两个例子，一切就会变得非常清晰。

#### 案例分析：一个场景，两种结果 (RR vs RC)

为了最清晰地展示 `RR` 和 `RC` 的区别，我们不再使用之前那两个令人困惑的表格，而是采用您建议的经典场景：在另一个事务提交前后，分别执行一次查询。

**设想的场景如下:**
1.  数据库中有一条记录，`money = 100`。
2.  事务A 和 事务B 同时开启。
3.  事务B **第一次**读取 `money` 的值。
4.  事务A 修改 `money` 为 `200` 并**提交**。
5.  事务B **第二次**读取 `money` 的值。

现在，我们来看这个完全相同的操作流程，在 `RR` 和 `RC` 两种隔离级别下会发生什么。

---

**情况一：在RR（可重复读）级别下**

| 步骤 | 操作 | 结果 | 行为分析 (事务B的视角) |
| :--- | :--- | :--- | :--- |
| 1 | 事务A `BEGIN;` | | |
| 2 | 事务B `BEGIN;` | | |
| 3 | 事务B `SELECT money;` | `100` | **这是第一次查询，创建Read View (我们称之为 ReadView_B1)**。此时事务A还未提交，是活跃事务。 |
| 4 | 事务A `UPDATE money=200;` | | 事务A修改数据。 |
| 5 | 事务A `COMMIT;` | | 事务A提交。 |
| 6 | 事务B `SELECT money;` | **`100`** | **这是第二次查询，但RR级别会复用旧的ReadView_B1**。根据旧快照的规则，事务A的修改对B仍然是不可见的。 |

**RR结论**: 事务B在整个事务期间，始终使用同一个Read View。因此，即使事务A已经提交，B的后续查询结果也不会改变，从而保证了“可重复读”。

---

**情况二：在RC（读已提交）级别下**

| 步骤 | 操作 | 结果 | 行为分析 (事务B的视角) |
| :--- | :--- | :--- | :--- |
| 1 | 事务A `BEGIN;` | | |
| 2 | 事务B `BEGIN;` | | |
| 3 | 事务B `SELECT money;` | `100` | **这是第一次查询，创建Read View (ReadView_B1)**。查询结束后，这个Read View**立即失效**。 |
| 4 | 事务A `UPDATE money=200;` | | 事务A修改数据。 |
| 5 | 事务A `COMMIT;` | | 事务A提交。 |
| 6 | 事务B `SELECT money;` | **`200`** | **这是第二次查询，RC级别会创建一个全新的Read View (ReadView_B2)**。在创建B2的这一刻，事务A**已经提交**，所以它的修改对于这个新快照是可见的。 |

**RC结论**: 事务B在每次查询时都会生成一个新的Read View。因此，在事务A提交后，B的第二次查询所创建的新Read View就能看到A的修改，导致两次查询结果不一致，这就是“不可重复读”。

通过这个对比，我们可以非常清晰地看到，**Read View的创建时机**正是区分 `RR` 和 `RC` 的命脉所在。

### 总结：RC与RR的关键区别

*   **RC（读已提交）**：每一次 `SELECT` 都获取一个新的Read View。这保证了它总能读到其他事务**已提交**的最新数据，但牺牲了事务内的读取一致性，可能导致“不可重复读”。

*   **RR（可重复读）**：只有第一次 `SELECT` 时获取一次Read View，之后**重复使用**。这保证了事务内的读取一致性（可重复读），但可能读到“过期”的数据。

MySQL的默认隔离级别是RR，它通过MVCC的这套机制，在大多数情况下避免了加锁，高效地实现了事务的隔离性。
