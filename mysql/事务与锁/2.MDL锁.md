# 2. MDL锁

## 目录
- [一、 MDL (Metadata Lock) - 元数据锁](#一-mdl-metadata-lock---元数据锁)
  - [1. 什么是元数据 (Metadata)？](#1-什么是元数据-metadata)
  - [2. MDL的核心目的：保证数据与结构的一致性](#2-mdl的核心目的保证数据与结构的一致性)
  - [3. MDL的加锁规则](#3-mdl的加锁规则)
  - [4. 经典生产事故："Waiting for table metadata lock"](#4-经典生产事故waiting-for-table-metadata-lock)
  - [5. 如何规避MDL问题](#5-如何规避mdl问题)
  - [6. MDL的生命周期：事务级 vs 语句级](#6-mdl的生命周期事务级-vs-语句级)

本章将深入探讨MySQL中除事务隔离级别外，为了实现并发控制而使用的具体锁机制。

## 一、 MDL (Metadata Lock) - 元数据锁

MDL不像行锁那样广为人知，但它在并发场景下至关重要，一旦出现问题，往往会造成严重的生产事故。

### 1. 什么是元数据 (Metadata)？

简单来说，元数据就是**描述数据的数据**，在MySQL中主要指**数据表的结构信息**。

-   **表结构**：`CREATE TABLE`语句定义的列、类型、索引等。
-   **视图、存储过程、触发器**等也属于元数据。

MySQL需要依据这些元数据来解析SQL、生成执行计划。

### 2. MDL的核心目的：保证数据与结构的一致性

MDL的唯一目标是：**保证在一个事务中，表的数据和它的结构定义是绝对一致的，防止在操作数据的过程中，表的结构发生变化。**

**想象一个灾难场景**：
1.  事务A正在对 `user` 表进行一个长时间的查询 (`SELECT`)。
2.  在查询中途，另一个会话执行了 `ALTER TABLE user DROP COLUMN age;` 并成功了。
3.  **结果**：事务A的查询执行到一半，发现 `age` 字段突然消失，这将导致数据错乱甚至数据库崩溃。

MDL就是为了防止这种情况而生的。

### 3. MDL的加锁规则

MDL是**自动**加锁的，无需手动操作。

-   当对表进行 **DML操作 (SELECT, INSERT, UPDATE, DELETE)** 时，会自动加上 **MDL读锁**。
-   当对表进行 **DDL操作 (ALTER TABLE, DROP TABLE)** 时，会自动加上 **MDL写锁**。

锁的兼容性如下：
-   **读锁 与 读锁**：兼容。多个事务可以同时对一张表进行DML操作。
-   **读锁 与 写锁**：冲突。当有事务在读写数据时，DDL操作必须等待。反之亦然。
-   **写锁 与 写锁**：冲突。不能同时对一张表进行结构变更。

### 4. 经典生产事故："Waiting for table metadata lock"

这个错误是MDL导致的最典型、最危险的生产问题。其形成过程如下（雪崩效应）：

1.  **会话A (长事务)**:
    -   执行 `BEGIN;`
    -   对 `user` 表执行一个查询。
    -   **不提交 (no COMMIT/ROLLBACK)**。
    -   **结果**: 会话A持有 `user` 表的 **MDL读锁**。

2.  **会话B (DDL操作)**:
    -   执行 `ALTER TABLE user ADD COLUMN new_col INT;`
    -   **结果**: 该操作需要申请 **MDL写锁**。由于与会话A的读锁冲突，会话B进入**等待状态**。

3.  **会话C, D, E... (新请求)**:
    -   新的 `SELECT`, `INSERT` 等请求涌入，试图操作 `user` 表。
    -   **结果**: 这些新请求都需要申请 **MDL读锁**。但在MySQL的锁队列中，写锁的优先级通常更高。因此，所有这些新的读锁申请，都会被阻塞在**会话B之后**，一起进入等待队列。

**最终**：一个未提交的长事务，阻塞了一个DDL，而这个DDL又阻塞了后续所有对该表的操作。数据库连接池迅速被占满，应用端表现为该表相关的服务完全卡死。

### 5. 如何规避MDL问题

-   **避免长事务**: 这是最根本的解决之道。在代码中确保事务尽可能简短，操作完成后必须及时提交或回滚。
-   **在业务低峰期执行DDL**: 变更表结构是高危操作，应安排在凌晨等业务低谷时段。
-   **为DDL设置等待超时**: 在执行DDL时，可以通过 `ALGORITHM=INPLACE, LOCK=NONE` (部分DDL支持) 或设置 `lock_wait_timeout` 来减少阻塞时间，避免无限期等待。
-   **上线前的检查**: 在执行DDL前，通过查询 `information_schema.innodb_trx` 表，检查当前是否存在未提交的长事务。

### 6. MDL的生命周期：事务级 vs 语句级

你提出的“生命周期”这个问题非常关键，它揭示了MDL锁一个重要的演进历史，也是理解长事务为何危险的根本原因。

**“生命周期”指的就是：这个锁从什么时候开始被持有，到什么时候才会被释放。**

#### 1. 现代MySQL (5.5及以后): **事务级别**

你总结得非常对：“事务！事务！事务！”。在现代MySQL中，MDL的生命周期是**绑定在整个事务上的**。

-   **加锁时机**：当一个事务中，**第一条**语句访问某张表时（无论是`SELECT`还是`INSERT`等），MySQL就会为这张表加上一个MDL。
-   **释放时机**：这个MDL**不会**在语句执行完后释放，而是会一直被该事务持有，直到事务**结束**（执行 `COMMIT` 或 `ROLLBACK`）时才会被释放。

**示例:**
```sql
-- 会话A
BEGIN;

-- 1. 此处对 user 表加上了 MDL读锁
SELECT * FROM user WHERE id = 1;

-- 2. 即使这条语句已执行完，MDL读锁依然被事务持有，并未释放！
-- 在这里可以执行很多其他操作，耗时很长...

-- 3. 直到事务结束，MDL读锁才被释放
COMMIT;
```
正是因为这个特性，一个长时间不提交的事务，会一直霸占着MDL锁，从而引发我们之前讨论的“雪崩”问题。

#### 2. 早期MySQL (5.5之前): **语句级别**

在老的版本中，MDL的生命周期是**绑定在单条语句上**的。

-   **加锁时机**：一条语句开始执行时加锁。
-   **释放时机**：该语句执行结束后**立刻释放**，不管事务是否还在继续。

<mark>这种模式虽然看起来能更快地释放锁，但它无法保证事务的“隔离性”</mark>，尤其是在DDL和DML混合的场景下，存在着我们之前提到的“查询中途表结构被改掉”的风险。因此，MySQL 5.5版本将其修改为了更安全、更符合逻辑的事务级生命周期。
