# 深入理解Java虚拟机：类加载过程详解

在前面的章节中，我们探讨了JVM的内存区域以及对象的创建与布局。但这一切都始于一个基础——**类**。一个`.java`文件是如何从磁盘上的二进制数据，转变为内存中可以被JVM理解和执行的结构？这个过程就是**类加载机制**。

本章将深入剖析一个类从被加载到虚拟机内存，直至最终卸载出内存的完整生命周期。

---

## 一、 目录

- [一、 目录](#一-目录)
- [二、 类的生命周期](#二-类的生命周期)
- [三、 详解类加载过程](#三-详解类加载过程)
  - [3.1 加载 (Loading)](#31-加载-loading)
  - [3.2 连接 (Linking)](#32-连接-linking)
    - [3.2.1 验证 (Verification)](#321-验证-verification)
    - [3.2.2 准备 (Preparation)](#322-准备-preparation)
    - [3.2.3 解析 (Resolution)](#323-解析-resolution)
  - [3.3 初始化 (Initialization)](#33-初始化-initialization)
    - [3.3.1 `<clinit>()` 方法](#331-clinit-方法)
    - [3.3.2 初始化触发时机](#332-初始化触发时机)
- [四、 类的卸载 (Unloading)](#四-类的卸载-unloading)

---

## 二、 类的生命周期

一个类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期可以分为七个阶段：

```mermaid
graph TD
    subgraph "生命周期"
        A[加载 Loading] --> B[连接 Linking];
        B --> C[初始化 Initialization];
        C --> D[使用 Using];
        D --> E[卸载 Unloading];
    end
    subgraph "连接阶段 (Linking)"
        B1[验证 Verification] --> B2[准备 Preparation] --> B3[解析 Resolution];
    end

    B --- B1; # 连接和验证之间是父子关系
```

其中，**加载、验证、准备、初始化和卸载**这五个阶段的顺序是确定的，类加载过程必须严格按照这个顺序**按需开始**（注意是“开始”，而不是“完成”，因为这些阶段通常是交叉混合进行的）。而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的动态绑定特性。

---

## 三、 详解类加载过程

类加载的核心过程包括**加载、连接、初始化**三个主要步骤。

### 3.1 加载 (Loading)

“加载”是整个类加载过程的第一个阶段。在这个阶段，虚拟机需要完成三件核心任务：

1.  **获取二进制流**：通过一个类的**全限定名**（例如 `java.lang.String`），获取定义这个类的二进制字节流。
2.  **转换数据结构**：将这个字节流所代表的静态存储结构，转换为方法区中的**运行时数据结构**。
3.  **创建Class对象**：在Java堆内存中生成一个`java.lang.Class`对象，这个对象将作为程序访问方法区中该类各种数据的入口。

**高度的灵活性**：
JVM规范对第一步“获取二进制流”的方式规定得非常灵活，并未限定其来源。这为Java技术生态的繁荣奠定了基础，开发者可以从各种来源加载类：
-   从本地文件系统的`.class`文件读取（最常见）。
-   从JAR、WAR、EAR等压缩包中读取。
-   从网络（例如Applet）。
-   动态计算生成（例如动态代理技术）。
-   由其他文件生成（例如JSP文件编译成的Servlet类）。

这个阶段是由**类加载器 (Class Loader)** 来完成的，Java默认的**双亲委-派模型**决定了当需要加载一个类时，具体由哪个加载器来执行。

### 3.2 连接 (Linking)

连接阶段是将已经加载的类合并到JVM运行时状态中的过程，它又细分为验证、准备和解析三个子阶段。

#### 3.2.1 验证 (Verification)

验证是连接的第一步，也是确保JVM安全的关键环节。其主要目的是确保读入的`.class`文件的字节流中包含的信息完全符合《Java虚拟机规范》的约束，保证这些信息作为代码运行后不会危害虚拟机自身的安全。

验证阶段大致会完成下面四个阶段的检验动作：
1.  **文件格式验证**：检查字节流是否符合Class文件格式规范（如魔数`0xCAFEBABE`、主次版本号等）。这是唯一一个基于二进制字节流进行操作的验证阶段。
2.  **元数据验证**：对字节码描述的信息进行语义分析，确保其符合Java语言规范的要求（如这个类是否有父类、是否继承了不允许被继承的类等）。
3.  **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这是整个验证过程中最复杂的一个阶段。
4.  **符号引用验证**：发生在**解析阶段**，确保后续的解析行为能正常执行。它会检查类自身以外的信息（常量池中的各种符号引用），比如通过字符串描述的全限定名是否能找到对应的类。

> **性能考虑**：验证阶段虽然重要，但也消耗资源。如果代码已经被反复验证过，在生产环境中可以通过 `-Xverify:none` 参数关闭大部分验证措施，以缩短类加载时间。但此参数在JDK 13后已被标记为废弃。

#### 3.2.2 准备 (Preparation)

准备阶段是正式为**类变量（即静态变量，被`static`修饰的变量）**分配内存并设置其**初始值**的阶段。这些变量所使用的内存都将在方法区中进行分配。

关于这个阶段，需要注意以下关键点：
1.  **分配对象**：此阶段只为**类变量**分配内存，不包括**实例变量**。实例变量将在对象实例化时随着对象一起分配在Java堆中。
2.  **内存位置**：从逻辑上讲，内存分配在**方法区**。但在JDK 7及以后的HotSpot虚拟机中，静态变量实际上是存放在**Java堆**中的`Class`对象旁边。
3.  **初始值**：这里设置的初始值**“通常”是数据类型的零值**，而不是代码中显式赋予的值。

| 数据类型 | 零值 |
| :--- | :--- |
| `int` | `0` |
| `long` | `0L` |
| `short` | `(short) 0` |
| `char` | `'\u0000'` |
| `byte` | `(byte) 0` |
| `boolean`| `false` |
| `float` | `0.0f` |
| `double` | `0.0d` |
| `reference` | `null` |

**示例**：
```java
public static int value = 123;
```
在准备阶段完成后，`value`的值是`0`，而不是`123`。将`value`赋值为`123`的`putstatic`指令，是在后续的**初始化**阶段才会被执行。

**特殊情况**：
如果类字段的字段属性表中存在`ConstantValue`属性（即被`static final`修-饰），那么在准备阶段，变量`value`就会被初始化为代码中设定的值。
```java
public static final int value = 123;
```
编译时，`javac`会为`value`生成`ConstantValue`属性，在准备阶段虚拟机就会根据这个属性将`value`赋值为`123`。

#### 3.2.3 解析 (Resolution)

解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。

-   **符号引用 (Symbolic Reference)**：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义地定位到目标即可。例如，用`java.io.PrintStream`这个全限定名来标识一个类。
-   **直接引用 (Direct Reference)**：可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。这个引用是和虚拟机内存布局直接相关的。

简单来说，解析就是**找到类、方法、字段在内存中的实际地址**的过程。这个过程主要针对类或接口、字段、类方法、接口方法等7类符号引用进行。

### 3.3 初始化 (Initialization)

初始化是类加载过程的最后一步。到了这个阶段，JVM才真正开始执行类中定义的Java程序代码（或者说字节码）。

#### 3.3.1 `<clinit>()` 方法

初始化阶段就是执行**类构造器方法 `<clinit>()`** 的过程。这个方法并不是由程序员直接编写的，而是`javac`编译器自动收集类中的所有**类变量的赋值动作**和**静态语句块（`static{}`块）**中的语句合并产生的。

**`<clinit>()` 方法的特点**：
1.  **执行顺序**：编译器收集的顺序是由语句在源文件中出现的顺序决定的。静态语句块中只能访问到定义在它之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。
2.  **父类优先**：虚拟机会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。因此，在虚拟机中第一个被执行的`<clinit>()`方法的类肯定是`java.lang.Object`。
3.  **非必需**：如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
4.  **线程安全**：虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待。

#### 3.3.2 初始化触发时机

虚拟机规范严格规定了**有且只有**六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始），这六种情况被称为对类的**主动使用**。

1.  **创建实例或访问静态内容**：
    -   遇到`new`指令：创建类的实例。
    -   遇到`getstatic`或`putstatic`指令：读取或设置一个类的静态字段（被`final`修饰、已在编译期把结果放入常量池的静态字段除外）。
    -   遇到`invokestatic`指令：调用一个类的静态方法。
2.  **反射**：使用`java.lang.reflect`包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。
3.  **初始化父类**：当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4.  **启动主类**：当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。
5.  **动态方法句柄**：当使用JDK 7的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
6.  **接口的默认方法**：当一个接口中定义了JDK 8新加入的默认方法（被`default`关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

---

## 四、 类的卸载 (Unloading)

类的卸载即该类的`Class`对象被垃圾收集器回收。一个类要被卸载，条件非常苛刻，必须同时满足以下三个条件：

1.  该类的所有实例都已经被垃圾回收，也就是说Java堆中不存在该类及其任何子类的实例。
2.  加载该类的`ClassLoader`已经被回收。
3.  该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

正因为条件严苛，Java虚拟机自带的类加载器（启动类加载器、扩展类加载器、应用程序类加载器）所加载的类，在虚拟机的生命周期中是**永远不会被卸载**的。因为加载这些类的ClassLoader实例永远都可以被访问到。

只有由**自定义的类加载器**加载的类，才有可能被卸-载。这在一些需要动态加载和卸载代码的场景（如OSGi、JSP热部署）中非常关键。
