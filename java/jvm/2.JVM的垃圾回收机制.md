# 深入理解Java虚拟机：垃圾回收机制

**目录**

- [一、 内存分配与回收原则](#一-内存分配与回收原则)
  - [1.1 对象优先在 Eden 区分配](#11-对象优先在-eden-区分配)
  - [1.2 大对象直接进入老年代](#12-大对象直接进入老年代)
  - [1.3 长期存活的对象将进入老年代](#13-长期存活的对象将进入老年代)
  - [1.4 空间分配担保](#14-空间分配担保)
  - [1.5 GC类型与触发时机](#15-gc类型与触发时机)
- [二、 死亡对象判断方法](#二-死亡对象判断方法)
  - [2.1 引用计数法](#21-引用计数法)
  - [2.2 可达性分析算法](#22-可达性分析算法)
  - [2.3 对象真的“死”了吗？](#23-对象真的死lema)
  - [2.4 如何判断一个常量是废弃常量？](#24-如何判断一个常量是废弃常量)
  - [2.5 如何判断一个类是无用的类？](#25-如何判断一个类是无用的类)
- [三、 垃圾收集算法](#三-垃圾收集算法)
  - [3.1 标记-清除算法 (Mark-and-Sweep)](#31-标记-清除算法-mark-and-sweep)
  - [3.2 复制算法 (Copying)](#32-复制算法-copying)
  - [3.3 标记-整理算法 (Mark-and-Compact)](#33-标记-整理算法-mark-and-compact)
  - [3.4 分代收集算法](#34-分代收集算法)
- [四、 垃圾收集器](#四-垃圾收集器)
  - [4.1 Serial 收集器](#41-serial-收集器)
  - [4.2 ParNew 收集器](#42-parnew-收集器)
  - [4.3 Parallel Scavenge 收集器](#43-parallel-scavenge-收集器)
  - [4.4 Serial Old 收集器](#44-serial-old-收集器)
  - [4.5 Parallel Old 收集器](#45-parallel-old-收集器)
  - [4.6 CMS 收集器 (Concurrent Mark Sweep) - 深度解析](#46-cms-收集器-concurrent-mark-sweep---深度解析)
    - [CMS的运作过程详解](#cms的运作过程详解)
    - [CMS的缺点](#cms的缺点)
  - [4.7 G1 收集器 (Garbage-First) - 深度解析](#47-g1-收集器-garbage-first---深度解析)
    - [G1的运作过程详解](#g1的运作过程详解)
    - [G1如何实现分代收集？](#g1如何实现分代收集)
  - [4.8 ZGC 收集器](#48-zgc-收集器)

## 一、 内存分配与回收原则

### 1.1 对象优先在 Eden 区分配

大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

**示例代码：**
```java
public class GCTest {
  public static void main(String[] args) {
    byte[] allocation1, allocation2;
    allocation1 = new byte[30900*1024];
    //allocation2 = new byte[900*1024];
  }
}
```

在分配 `allocation1` 后，Eden 区几乎被占满。如果此时再尝试为 `allocation2` 分配内存，Eden 区空间不足，将触发 Minor GC。

在GC期间，虚拟机会发现 `allocation1` 无法放入 Survivor 空间，因此会通过**分配担保机制**将其提前转移到老年代。由于老年代空间足够，不会发生 Full GC。Minor GC 后，如果 Eden 区有足够空间，后续的对象（如`allocation2`）仍会在 Eden 区分配。

### 1.2 大对象直接进入老年代

大对象是指需要大量连续内存空间的对象（如长字符串、大数组）。

让大对象直接进入老年代是一种优化策略，目的是避免其在新生代中引起频繁的GC。

-   **G1收集器**：根据 `-XX:G1HeapRegionSize` 和 `-XX:G1MixedGCLiveThresholdPercent` 参数动态决定。
-   **Parallel Scavenge收集器**：没有固定的阈值，由虚拟机根据当前堆内存情况和历史数据动态决定。

### 1.3 长期存活的对象将进入老年代

为了区分新生代和老年代的对象，虚拟机为每个对象定义了一个年龄（Age）计数器。

1.  新对象在 Eden 区出生。
2.  经过一次 Minor GC 后仍然存活，并且能被 Survivor 区容纳的，将被移动到 Survivor 区，年龄设为1。
3.  对象在 Survivor 区每经历一次 Minor GC，年龄就增加1。
4.  当年龄达到一定阈值（默认为15），就会被晋升到老年代。该阈值可以通过 `-XX:MaxTenuringThreshold` 参数设置。

### 1.4 空间分配担保

**每一次Minor GC之前，JVM都会进行一次“空间分配担保”的风险评估**。这是一种前置检查，旨在确保老年代有足够的空间来容纳从新生代可能晋升过来的对象，从而尽可能地避免在Minor GC过程中因老年代空间不足而触发代价高昂的Full GC。

**为什么需要担保？**

在进行Minor GC时，存活下来的对象需要被复制到To Survivor区。但总会存在一些情况导致对象必须直接进入老年代，例如：
*   对象年龄达到阈值（`-XX:MaxTenuringThreshold`）。
*   **一个关键的场景**：存活对象的总大小超过了To Survivor区的容量。

在这些情况下，对象会被**提前晋升（Promote）**到老年代。空间分配担保机制的核心目的，就是为了应对这种晋升情况，确保老年代能“兜底”。如果老年代无法容纳这些晋升的对象，就会发生“**晋升失败 (Promotion Failure)**”，这将强制触发一次Full GC。

> **“代价高昂”的简单解读**
>
> 为什么说在Minor GC过程中因“晋升失败”而触发的Full GC“代价高昂”？
>
> -   **计划外的紧急中断 vs 计划内的操作**：
    >   -   **担保检查失败**：在Minor GC开始前就预判到风险，于是**主动放弃Minor GC，直接执行Full GC**。这是一次计划内的、有序的操作。
    >   -   **晋升失败**：Minor GC已经进行到一半，突然发现老年代空间不够，只能**紧急中断当前做到一半的Minor GC工作，然后立刻触发Full GC**来救场。
> -   **额外的工作被浪费**：在“晋升失败”的场景下，JVM为进行中的Minor GC已经付出的CPU和时间**完全白费了**，是纯粹的沉没成本。
> -   **总停顿时间更长**：最终的总停顿时间是“被中断的Minor GC的无效时间” + “一次完整Full GC的时间”，通常比直接执行一次Full GC要长。
>
> 因此，空间分配担保就像一个风险预判机制，它的目的就是用一次可控的预检查，来避免这种代价更高的“运行时意外”。

**担保流程（JDK 6 Update 24后，已成默认行为）：**

Minor GC开始前，虚拟机会进行以下检查：

1.  **第一层检查（绝对安全线）**：检查**老年代最大可用的连续空间**是否**大于** **新生代所有对象的总大小**（即Eden区 + From Survivor区的大小）。
    *   **如果大于**：说明这是绝对安全的。即使新生代所有对象全部存活并晋升，老年代也放得下。因此，可以**放心大胆地执行Minor GC**。
    *   **如果小于**：说明存在风险。不能保证老年代能容纳所有晋升对象。进入第二层检查。

2.  **第二层检查（风险决策线）**：此时，虚拟机会进行一次“赌博”。它不再以“新生代所有对象总大小”这个最坏情况作为标准，而是以一个更贴近实际的指标——“**历次晋升到老年代对象的平均大小**”来进行判断。
    *   它会检查**老年代最大可用的连续空间**是否**大于** **历次晋升的平均大小**。
        *   **如果大于**：虚拟机认为这次Minor GC后晋升的对象大小，很可能也会低于这个平均值，所以老年代应该能应付。于是，它会**冒险进行一次Minor GC**。这是一种基于历史数据的乐观策略。
        *   **如果小于**：说明连容纳平均大小的晋升对象都做不到，风险太高。虚拟机会放弃本次Minor GC，**直接触发一次Full GC**。

**冒险失败的情况**

如果JVM在第二步检查通过后，决定“冒险”执行Minor GC，但实际需要晋升的对象大小超过了老年代的可用空间，就会发生“晋升失败 (Promotion Failure)”，此时JVM必须立刻停下来，转而触发一次Full GC。

**总结：**

空间分配担保机制，本质上是**每次Minor GC前的一次例行检查**，它在“Minor GC + 可能的Promotion Failure”与“直接Full GC”之间做权衡。它通过检查历史平均数据，试图在不触发Full GC的前提下，尽可能地完成Minor GC，从而提升整体的吞吐量和响应速度。在JDK 6 Update 24之后，这个检查流程已经成为默认且唯一的行为逻辑。

### 1.5 GC类型与触发时机

-   **新生代GC (Minor GC / Young GC)**:
    -   **触发时机**：当 Eden 区空间不足，无法为新创建的对象分配内存时触发。
    -   **特点**：发生频繁，回收速度快，引起的“Stop The World”(STW)停顿时间短。

-   **老年代GC (Major GC / Old GC)**:
    -   **定义**：指只对老年代进行的垃圾回收。目前很多垃圾收集器（如 G1 之前的）都没有独立的 Major GC，通常 Major GC 会伴随着 Minor GC 至少一次，也就是我们常说的 Full GC。
    -   **触发时机**：通常是在老年代空间不足时。例如，在 Minor GC 后，存活的对象要晋升到老年代，但老年代空间不足以容纳它们。

-   **整堆GC (Full GC)**:
    -   **定义**：清理整个 Java 堆（新生代和老年代）和方法区的垃圾回收。
    -   **危害**：速度慢，引起的 STW 停顿时间长，对应用性能影响巨大，应尽量避免。
    -   **常见触发时机**：
        1.  **晋升失败 (Promotion Failed)**：在进行 Minor GC 时，存活的对象（经过 Survivor 区或大对象）需要晋升到老年代，但老年代没有足够的连续空间来容纳它们。
        2.  **空间分配担保失败**：在执行 Minor GC 前，JVM 会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果不满足，并且未开启分配担保策略，或者历次晋升到老年代对象的平均大小也大于该空间，则会触发 Full GC。
        3.  **元空间/永久代空间不足**：当方法区（Metaspace 或 PermGen）满了，会触发 Full GC。
        4.  **显式调用 `System.gc()`**：程序代码中主动调用 `System.gc()` 方法。虽然不保证立即执行，但虚拟机会建议执行 Full GC。

#### Minor GC vs Full GC：对系统性能的影响

GC过程主要消耗的是CPU资源，而其对应用最核心、最直接的影响，来自于一个被称为**“Stop-The-World”（STW）**的机制。

**Stop-The-World (STW)是什么？**
可以理解为JVM的“时间暂停”。为了确保垃圾回收时内存状态的一致性（防止在标记时引用关系还在变化），JVM在执行GC时，会**冻结所有正在运行的应用程序线程**。此时，你的所有业务逻辑都会暂停，整个应用对外表现为“卡顿”或“无响应”，直到GC结束。

---

##### 新生代GC (Minor GC) 的影响：频繁但短暂的“小卡顿”

*   **会暂停吗？**：**是的，Minor GC会触发STW**。
*   **为什么影响小？**：
    1.  **范围小**：Minor GC只扫描和处理**新生代**，这个区域通常不大。
    2.  **效率高**：新生代中的对象绝大多数都是垃圾。复制算法在这种场景下效率极高，因为它只需要复制少量存活的对象。
*   **停顿时间**：通常非常短，一般在**几十毫秒以内**。
*   **影响**：对于大多数应用，这种级别的停顿用户几乎无感知。它是一种**常规、健康、低成本**的操作。

---

##### 整堆GC (Full GC) 的影响：稀少但致命的“大雪崩”

*   **会暂停吗？**：**是的，Full GC一定会触发STW**，并且这是它最致命的问题。
*   **为什么影响大？**：
    1.  **范围大**：Full GC要处理**整个Java堆**（新生代 + 老年代），有时还包括**元空间**。
    2.  **效率低**：老年代中对象存活率高，使用的“标记-整理”或“标记-清除”算法本身就比复制算法要慢，且需要处理的对象和引用关系远比新生代复杂。
*   **停顿时间**：**非常长**。根据堆大小，停顿时间可以从**几百毫秒到数秒，甚至更长**。
*   **影响**：对线上服务来说是**灾难性**的。一次几秒的Full GC意味着这期间所有用户请求都无法响应。因此，**几乎所有JVM性能调优的首要目标，都是想方设法地减少甚至消除Full GC的发生。**

| 特性     | 新生代GC (Minor GC)          | 整堆GC (Full GC)                  |
| :------- | :--------------------------- | :-------------------------------- |
| **STW**  | **会**                       | **会**                            |
| **停顿时间** | 短（毫秒级）                 | 长（百毫秒级 ~ 秒级）             |
| **发生频率** | 频繁                         | 应该非常稀少                      |
| **处理区域** | 仅新生代                     | 整个堆（新生代+老年代）+元空间    |
| **性能影响** | 通常可忽略，健康的常规操作   | 性能杀手，应极力避免              |

---

## 二、 死亡对象判断方法

在对堆进行垃圾回收前，首先需要判断哪些对象已经“死亡”（即不再被任何途径使用）。

### 2.1 引用计数法

为对象添加一个引用计数器，每当有地方引用它时，计数器加1；引用失效时，减1。任何时候计数器为0的对象就是不可能再被使用的。

-   **优点**：实现简单，效率高。
-   **缺点**：难以解决对象之间**循环引用**的问题。

**循环引用示例：**
```java
public class ReferenceCountingGC {
    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // 假设发生GC，objA和objB是否能被回收？
    }
}
```
在上述代码中，`objA` 和 `objB` 相互引用，导致它们的引用计数器都不为0，因此引用计数算法无法回收它们。

### 2.2 可达性分析算法

这是当前所有主流商用虚拟机都在使用的对象存活判断算法。它的核心思想是**从一组固定的、活跃的引用（称为“GC Roots”）出发，遍历所有可达的对象，形成一条条“引用链”。当一个对象到所有GC Roots之间都没有任何引用链相连时，就证明此对象是程序不再使用的，可以被回收**。

#### 核心问题一：为什么“GC Roots不可达”就等于“可以回收”？

这个算法的底层逻辑是：**一个对象要被程序使用，程序就必须要有办法能访问到它**。

在程序运行的任何时刻，所有正在被使用的对象，都必然直接或间接地被一组特殊的、活跃的引用所持有。这组引用就是我们寻找对象的**起点**。如果从所有的“起点”出发，用尽所有可能的引用路径都无法到达某个对象，那就意味着：**你的程序已经永远失去了访问这个对象的能力**。

既然程序永远无法再使用它，那它对于程序来说就成了无用的数据，继续占用内存就是一种浪费。因此，GC就可以安全地回收它。

**GC Roots 就是这组“起点”引用的集合。** 它们是JVM在进行垃圾回收时，不用任何前置条件就能直接定位到的、确定为“存活”的引用。

#### 核心问题二：哪些对象可以作为GC Roots？为什么是它们？

能够作为GC Roots的对象都有一个共同特点：**它们是当前程序执行状态下，最直接、最活跃的“触手”，是程序能访问到其他对象的“入口”**。

主要包括以下几种：

-   **虚拟机栈（栈帧中的局部变量表）中引用的对象**
    -   **解读**：虚拟机栈记录了当前所有正在执行的方法。每个方法（栈帧）里的局部变量，就是当前方法操作对象的直接“抓手”。比如 `MyObject obj = new MyObject();`，`obj` 这个引用就存放在局部变量表里。只要这个方法还在执行，`obj` 指向的对象就必须是存活的。这是最活跃、最确定的一种引用。

-   **方法区中类静态属性引用的对象**
    -   **解读**：静态属性（`static` 变量）是跟“类”本身绑定的，而不是跟某个实例对象绑定。它的生命周期和类的生命周期一样长，几乎可以说是“与程序共存亡”。因此，被静态变量引用的对象，被认为是全局存活的，必须作为GC Root。

-   **方法区中常量引用的对象**
    -   **解读**：这里的常量主要是指字符串常量池里的引用。比如代码里有一个 `"hello"` 字符串，这个字符串对象在常量池里。如果某个地方引用了它，那它就是存活的。这和静态属性类似，是一种全局性的、长生命周期的引用。

-   **本地方法栈中 JNI (Native 方法) 引用的对象**
    -   **解读**：当Java代码通过JNI调用C或C++等本地代码时，本地代码可能会持有一个Java对象的引用。JVM的垃圾回收器无法直接探知本地代码的内部情况，所以它必须假设：任何被本地代码引用的Java对象都是存活的。这些引用就构成了GC Roots的一部分，以防止GC错误地回收了本地代码还在使用的Java对象。

-   **所有被同步锁（`synchronized` 关键字）持有的对象**
    -   **解读**：在 `synchronized(obj)` 这段代码中，`obj` 对象被用作了锁监视器（Monitor）。为了保证线程同步的正常工作，持有锁的线程以及正在等待这个锁的线程，都必须保证这个锁对象 `obj` 是存活的。否则锁就失效了。因此，正在被用作锁的对象也必须是GC Root。

### 2.3 对象真的“死”了吗？

1.可达性分析发现不可达
2.如果可达，检查其引用，
强不会被回收
软：内存不足时回收
弱，虚：都会被回收

### 2.4 如何判断一个常量是废弃常量？

运行时常量池主要回收的是废弃的常量。例如，字符串常量池中的字符串`"abc"`，如果当前没有任何`String`对象引用它，它就是废弃常量。如果发生内存回收且有必要，`"abc"`就会被清理出常量池。

### 2.5 如何判断一个类是无用的类？

方法区主要回收的是无用的类。判定一个类是否“无用”的条件非常苛刻，需要同时满足以下3个条件：

1.  该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例。
2.  加载该类的 `ClassLoader` 已经被回收。
3.  该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机**可以**对满足上述条件的无用类进行回收，但这并非必然行为。

---

## 三、 垃圾收集算法

### 3.1 标记-清除算法 (Mark-and-Sweep)

这是最基础的收集算法，分为“标记”和“清除”两个阶段：首先标记出所有**需要回收**的对象，在标记完成后统一回收所有被标记的对象（或者反过来，标记存活对象，回收未标记的）。

-   **问题1：效率问题**：标记和清除两个过程的效率都不高。
-   **问题2：空间问题**：标记清除后会产生大量不连续的内存碎片，可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 3.2 复制算法 (Copying)

为了解决标记-清除算法的效率和内存碎片问题，复制算法应运而生。

#### 经典复制算法思想

它将可用内存按容量划分为大小相等的两块（A和B），每次只使用其中的一块（A）。当A区的内存用完了，就触发GC，将A区中所有**还存活着的对象**复制到另一块B区上面，然后一次性地把A区全部清理掉。这样一来，内存就永远是连续的，也不会有碎片问题。

-   **优点**：实现简单，运行高效，不会产生内存碎片。
-   **缺点**：
    -   **可用内存减半**：这是最大的代价，内存的利用率极低。
    -   **不适合老年代**：如果对象存活率高（老年代的特点），需要执行大量的复制操作，效率会急剧下降。

#### 新生代的优化版复制算法 (Appel-style Collector)

现代商业虚拟机**并没有采用简单的1:1划分**来回收新生代，而是做了一个聪明的优化。该设计基于一个重要的观察：**新生代中超过98%的对象都是“朝生夕死”的**。因此，并不需要预留一半的内存来存放存活对象。

**具体做法是：**
将新生代内存划分为**一块较大的Eden空间**和**两块较小的、大小相等的Survivor空间**（通常称为From和To，或者S0和S1）。

-   **默认比例**：Eden : S0 : S1 = 8 : 1 : 1。
-   **内存使用**：平时只使用Eden和其中一块Survivor区（From区）。所以，新生代实际可用的内存是总容量的90%（80% Eden + 10% From），空间利用率大大提高。

**工作流程详解：**

1.  **对象分配**：新创建的对象绝大多数都在**Eden区**分配。
2.  **触发Minor GC**：当Eden区满时，触发Minor GC。
3.  **扫描与复制**：
    -   GC会扫描 **Eden区** 和 **From区**，找出所有存活的对象。
    -   然后，将这些存活的对象统一复制到 **To区**（另一块空闲的Survivor区）。
    -   在复制过程中，对象的年龄（Age）会加1。
4.  **清空**：GC执行完毕后，**Eden区** 和 **From区** 会被一次性完全清空，变成空闲状态。
5.  **角色互换**：From区 和 To区 的角色发生互换。刚才的To区现在变成了下一次GC时的From区，而刚才的From区则变成了下一次GC时的To区。

这个“在两块Survivor区之间来回复制”的过程会持续进行，直到一个对象的年龄达到晋升阈值（默认为15），才会被晋升到老年代。

**如果Survivor区放不下了怎么办？**

这是一个非常关键的异常情况。如果在Minor GC期间，Eden区和From区的所有存活对象总大小，超过了To区的容量，那么多出来的对象就会被**直接晋升（Promote）**到**老年代**。这依赖于老年代的**空间分配担保**机制。

### 3.3 标记-整理算法 (Mark-and-Compact)

该算法是根据老年代的特点提出的。标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

-   **优点**：解决了内存碎片问题。
-   **缺点**：由于多了整理这一步，效率相对较低。适合老年代这种GC频率不高的场景。

### 3.4 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”算法。它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为**新生代**和**老年代**，然后根据各个年代的特点采用最适当的收集算法。

-   **新生代**：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
-   **老年代**：因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**“标记—清除”或者“标记—整理”**算法来进行回收。

---

## 四、 垃圾收集器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。没有万能的收集器，需要根据具体应用场景选择。

**JDK 默认垃圾收集器：**
-   **JDK 8**: Parallel Scavenge (新生代) + Parallel Old (老年代)
-   **JDK 9 ~ JDK 22**: G1

### 4.1 Serial 收集器

最基本、发展历史最悠久的**单线程**收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程（"Stop The World"）。

-   **算法**：新生代采用**标记-复制**算法，老年代采用**标记-整理**算法。
-   **优点**：简单而高效（在单线程环境下），没有线程交互的开销。
-   **适用场景**：Client模式下的虚拟机。

### 4.2 ParNew 收集器

Serial收集器的**多线程**版本。除了使用多线程进行垃圾收集之外，其余行为（控制参数、收集算法、回收策略等）与Serial收集器完全一样。

-   **算法**：新生代采用**标记-复制**算法，老年代采用**标记-整理**算法。
-   **适用场景**：它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，**只有它能与CMS收集器配合工作**。

> **并行 (Parallel) vs 并发 (Concurrent)**
> -   **并行**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
> -   **并发**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行）。

### 4.3 Parallel Scavenge 收集器

Parallel Scavenge 是一款新生代**多线程**收集器，同样使用**标记-复制**算法。从表面上看，它和ParNew非常相似，但它的核心特点在于**设计哲学的不同**。

CMS、G1等收集器关注的是如何**尽可能缩短单次GC的停顿时间（Low Latency）**，以提升用户体验。而Parallel Scavenge关注的则是如何达到一个**可控制的吞吐量（High Throughput）**。

#### 深入解读“可控制的吞吐量”

**1. 什么是吞吐量 (Throughput)？**

在JVM GC的语境下，吞吐量指的是CPU用于**运行用户代码的时间**与**CPU总消耗时间**的比值。其计算公式为：

\[ \text{吞吐量} = \frac{\text{运行用户代码时间}}{\text{运行用户代码时间} + \text{垃圾收集时间}} \]

例如，如果程序总共运行100分钟，其中GC占用了1分钟，那么吞吐量就是99%。高吞吐量意味着CPU的利用率高，大部分时间都在执行有效的业务逻辑。这对于后台计算、数据处理等任务至关重要。

**2. 什么是“可控制”？**

“可控制”是Parallel Scavenge的核心特性。它允许你向JVM设定性能**目标**，而不是手动去调整具体的内存参数。JVM会根据这些目标，自动进行优化。

主要通过两个参数来设定目标：
-   **`-XX:GCTimeRatio=<N>`**：设置**吞吐量目标**。它定义了“用户代码运行时间”与“GC时间”的比值。
    -   计算公式为：`吞吐量目标 = N / (N + 1)`。
    -   默认值为`99`，即吞吐量目标为 `99 / (100) = 99%`，允许GC占用不超过1%的时间。如果你设置为`19`，则目标为`19 / (20) = 95%`。
-   **`-XX:MaxGCPauseMillis=<M>`**：设置**最大GC停顿时间目标**，单位为毫秒。这是一个软目标，JVM会尽力达成，并在吞吐量和停顿时间之间做权衡。

**3. JVM如何自动“控制”？**

当你设置了上述目标后，Parallel Scavenge收集器自带的**自适应调节策略 (Ergonomics / Adaptive Size Policy)** 会自动工作。JVM会持续监控性能数据，如果发现实际表现不满足你设定的目标，它就会**动态地、自动地调整Java堆的各项参数**，包括新生代大小、Eden/Survivor比例、晋升年龄等，以期达到预设目标。

**举例**：如果JVM发现实际吞吐量低于目标值，它可能会自动增大新生代的空间来降低Minor GC的频率，从而提升总吞吐量。

这种“目标导向”的自动化调优，是Parallel Scavenge与其他收集器最大的区别，极大地简化了GC性能调优的复杂度。

---
-   `-XX:+UseParallelGC`: 使用Parallel Scavenge + 老年代串行 (Serial Old)。
-   `-XX:+UseParallelOldGC`: 使用Parallel Scavenge + 老年代并行 (Parallel Old)。

它适合在后台运算而不需要太多交互的任务，提供了自适应调节策略。**这是 JDK 1.8 默认的收集器组合** (Parallel Scavenge + Parallel Old)。

### 4.4 Serial Old 收集器

Serial收集器的老年代版本，是一个**单线程**收集器，使用**标记-整理**算法。

-   **主要用途**：
    1.  在JDK 1.5及以前版本中与Parallel Scavenge收集器搭配使用。
    2.  作为CMS收集器的后备预案。

### 4.5 Parallel Old 收集器

Parallel Scavenge收集器的老年代版本，使用**多线程**和**标记-整理**算法。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑它和Parallel Scavenge的组合。

### 4.6 CMS 收集器 (Concurrent Mark Sweep) - 深度解析

CMS是一款里程碑式的收集器，它的核心目标是**获取最短的回收停顿时间（STW）**。这对于需要快速响应用户的互联网应用或B/S系统至关重要，能显著提升用户体验。它是第一款真正意义上的**并发**收集器，实现了让垃圾收集线程与用户线程在大部分时间内同时工作。

**核心思想：**
CMS将最耗时的**对象标记**和**垃圾清除**两个步骤设计为可以与用户线程并发执行，从而将STW时间缩短到仅剩两个非常短暂的必要暂停。

---

#### CMS的运作过程详解

CMS基于“**标记-清除**”算法，整个过程分为四个核心步骤：

1.  **初始标记 (Initial Mark)**
    -   **状态**：**需要 Stop The World (STW)**。
    -   **任务**：这个阶段的任务非常简单且快速：仅仅是标记出由 **GC Roots** 能**直接关联**到的第一批对象。例如，虚拟机栈中引用的对象、静态变量引用的对象等。
    -   **特点**：速度极快，因为只处理根节点，所以STW停顿时间非常短。

2.  **并发标记 (Concurrent Mark)**
    -   **状态**：**与用户线程并发执行**。
    -   **任务**：这是最耗时的一个阶段。GC线程会从“初始标记”阶段找到的根对象开始，**递归地遍历整个对象引用链**，找出所有存活的对象。
    -   **如何实现并发？**：GC线程在后台默默地进行对象标记，而您的应用程序线程可以继续正常运行，处理用户请求。两者互不干扰（但会抢占CPU资源）。
    -   **面临的问题**：因为用户线程仍在运行，所以它可能会改变对象间的引用关系。比如，一个原本被标记为存活的对象，可能在并发标记期间被用户线程断开了所有引用，变成了垃圾；反之，一个未被访问到的对象，可能被用户线程建立了一个新的引用。这会导致标记结果不完全准确。

3.  **重新标记 (Remark)**
    -   **状态**：**需要 Stop The World (STW)**。
    -   **任务**：这个阶段是为了**修正**在“并发标记”期间，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。
    -   **如何实现？**：JVM通过一种叫做“**增量更新 (Incremental Update)**”的机制来跟踪并发标记期间的引用变化。简单来说，JVM会记录下那些被用户线程修改过的内存区域（这块区域被称为“脏卡”）。在重新标记阶段，GC线程只需重新扫描这些“脏卡”区域的对象，并对引用链进行微调，而无需再次扫描整个堆。
    -   **特点**：虽然是STW，但因为只处理少量被修改过的对象，所以停顿时间比“初始标记”稍长，但远比整个“并发标记”阶段短得多。

4.  **并发清除 (Concurrent Sweep)**
    -   **状态**：**与用户线程并发执行**。
    -   **任务**：GC线程开始对未被标记的区域（即垃圾对象）进行回收，释放它们所占用的内存。
    -   **面临的问题**：如果在清除过程中，用户线程又产生了新的垃圾怎么办？这些新产生的垃圾被称为“**浮动垃圾 (Floating Garbage)**”。CMS无法在本次收集中处理它们，只能留到下一次GC时再清理。
    -   **并发清除时用户线程关联对象怎么办？**：这个问题在“重新标记”阶段已经解决了。只要一个对象在“重新标记”结束后被确定为存活，它就不会在本次的“并发清除”中被回收。

---

#### CMS的缺点

1.  **CPU资源敏感**：并发阶段虽然不暂停用户线程，但GC线程会占用一部分CPU，导致应用程序总吞吐量降低。
2.  **内存碎片**：基于“标记-清除”算法，会产生大量不连续的内存碎片，当需要分配大对象时可能会因空间不足而提前触发Full GC。
3.  **并发模式失败 (Concurrent Mode Failure)**：如果在并发清理期间，用户线程需要分配的内存超过了老年代的剩余空间，就会发生“并发模式失败”。此时，JVM会紧急启动后备预案：冻结所有用户线程（STW），并临时启用Serial Old收集器来完成一次Full GC，这会导致非常长的停顿。

### 4.7 G1 收集器 (Garbage-First) - 深度解析

G1（Garbage-First）是当今服务端应用的主流垃圾收集器，被设计用来替代CMS。它是一款面向**服务器端**、**大内存**、**多核处理器**环境的收集器，其核心目标是在满足高吞吐量的同时，还能建立**可预测的停顿时间模型**。

**核心思想：化整为零，按价值回收**

1.  **化整为零 (Region)**：G1彻底改变了传统分代收集器对内存的物理划分。它将整个Java堆划分为多个大小相等的独立区域（Region）。每个Region都可以根据需要扮演Eden、Survivor或老年代（Old）的角色。这种设计使得内存使用更加灵活，也为大对象的存储（Humongous Region）提供了专门的解决方案。
2.  **按价值回收 (Garbage-First)**：G1会跟踪每个Region中垃圾的堆积价值（即回收后能获得多少空间），并在后台维护一个优先级列表。当触发回收时，它会根据用户设定的最大停顿时间（`-XX:MaxGCPauseMillis`），优先选择那些**回收价值最高**的Region进行回收，这也就是“Garbage-First”名字的由来。

---

#### G1的运作过程详解

G1的回收过程同样涉及并发和STW阶段，但其回收模型与CMS有本质区别：

1.  **初始标记 (Initial Mark)**
    -   **状态**：**STW**。
    -   **任务**：与CMS类似，仅标记GC Roots能直接关联的对象。这个过程通常会**借用（Piggybacking）一次新生代GC（Minor GC）**来完成，因此开销很小。

2.  **并发标记 (Concurrent Marking)**
    -   **状态**：**并发执行**。
    -   **任务**：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。这个过程耗时较长，但可以和应用程序并行。

3.  **最终标记 (Final Marking)**
    -   **状态**：**STW**。
    -   **任务**：与CMS的“重新标记”类似，修正并发标记期间产生的变动。G1使用了更高效的算法（SATB - Snapshot-At-The-Beginning），其停顿时间通常是可控的。

4.  **筛选回收 (Live Data Counting and Evacuation)**
    -   **状态**：**STW，且是并行执行**。这是G1最具特色的阶段。
    -   **任务**：
        1.  首先，对各个Region的回收价值和成本进行排序，并根据用户期望的GC停顿时间制定回收计划（决定回收哪些Region）。
        2.  然后，把决定要回收的那些Region中的**存活对象**，通过**复制**的方式，移动到空的Region中去。
        3.  最后，将旧的、待回收的Region直接清空。
    -   **如何利用多核？**：这个“复制-清空”的过程会启动**多个GC线程并行处理**，极大地利用了多核CPU的优势，提高了回收效率。
    -   **为什么能整合空间？**：因为采用了**复制算法**，G1在回收的同时就完成了内存的整理，从根本上避免了内存碎片的产生。

---

#### G1如何实现分代收集？

G1的分代是**逻辑上**的，而非物理上的。它将堆划分为一个个Region，每个Region都可以扮演不同的角色，这种设计带来了高度的灵活性。

-   **逻辑分代与Region角色**
    G1不需要物理上连续的空间来定义新生代和老年代。它会动态地将一部分Region标记为Eden区，一部分标记为Survivor区。Survivor区的Region同样遵循“From”和“To”的逻辑，用于对象的复制和年龄计算。

-   **新生代GC (Young GC)**
    1.  当Eden区的Region被占满，无法为新对象分配空间时，G1会触发一次新生代GC。
    2.  这次GC的回收范围（CSet, Collection Set）包括**所有Eden Region**和**所有From Survivor Region**。
    3.  G1会扫描这些Region中的存活对象，并将它们通过复制算法，拷贝到新的、空闲的To Survivor Region中去。
    4.  在这个过程中，如果To Survivor Region空间不足，或者某个对象的年龄达到了晋升阈值，那么这些对象会被直接晋升（复制）到老年代的Region中。
    5.  GC结束后，原来的Eden和From Survivor Region被完全清空，回收为可用Region。

-   **混合GC (Mixed GC)**
    Young GC只负责回收新生代的Region。但当整个堆的内存占用率达到预设阈值（由 `-XX:InitiatingHeapOccupancyPercent` 控制）时，G1会启动一个并发标记周期（初始标记 -> 并发标记 -> 最终标记）。
    
    并发标记周期结束后，G1已经计算出了哪些老年代Region的回收价值最高（即垃圾最多）。随后，G1会触发一次**混合GC**。
    
    Mixed GC的回收范围（CSet）不仅包括**全部的新生代Region**（Eden + Survivor），还会额外选择**一部分回收价值高的老年代Region**一并进行回收。它依然采用复制算法，将存活对象拷贝到新的Region，从而在回收垃圾的同时，也逐步地整理了老年代的内存碎片。

总之，G1通过引入Region和“Garbage-First”的理念，完美地解决了CMS的内存碎片问题。它通过Young GC常规地清理新生代，再通过Mixed GC增量式、有选择地清理老年代，从而实现了更可控的停顿时间，因此更适合现代大内存、多核心的服务器环境。

### 4.8 ZGC 收集器

ZGC是一款可伸缩的低延迟垃圾收集器，旨在将GC暂停时间控制在几毫秒以内。

-   **算法**：基于**标记-复制**算法，但对其做了重大改进。
-   **特点**：
    -   暂停时间不随堆大小的增加而增加。
    -   可以处理从几百兆到几TB的堆。
    -   出现Stop The World的情况更少，但会牺牲一些吞吐量。
-   **版本**：
    -   Java 11 中引入，处于实验阶段。
    -   Java 15 中可以正式使用。
    -   Java 21 中引入了**分代ZGC** (`-XX:+ZGenerational`)，暂停时间可以缩短到1毫秒以内。

通过 `-XX:+UseZGC` 参数启用。
