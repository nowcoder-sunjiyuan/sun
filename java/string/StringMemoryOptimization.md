# Java 字符串内存优化：常量池、intern() 与 G1 排重

## 核心困惑：`String a = "abc";` 不是已经在常量池了吗？

这是一个非常普遍且关键的疑问。你的理解是正确的，但它只覆盖了一种特定的情况。

当你这样写代码时：
```java
String a = "abc";
String b = "abc";
System.out.println(a == b); // 结果永远是 true
```
在编译期，编译器看到 `"abc"` 这个**字面量**，就会把它放入**字符串常量池**。当处理第二行时，它会发现池中已有 `"abc"`，因此会直接让 `b` 指向池中**同一个对象**。

**然而，在真实的应用中，绝大部分字符串都是在程序运行时动态创建的**，它们不会自动进入常量池。

### 运行时动态创建的字符串

这些字符串默认都在**堆内存**上创建新对象，即使内容完全相同。

1.  **`new String()`**
    ```java
    String c = new String("abc"); // 强制在堆上创建新对象
    String d = new String("abc"); // 强制在堆上又创建一个新对象
    // c 和 d 的内存地址不同
    ```

2.  **来自外部数据**：数据库查询、网络请求、文件读取、JSON 解析等。
    ```java
    // 从数据库读出两条记录，它们的 status 字段内容都是 "SUCCESS"
    String status1 = resultSet1.getString("status");
    String status2 = resultSet2.getString("status");
    // status1 和 status2 是堆上两个独立的对象
    ```

3.  **字符串拼接结果**
    ```java
    String s1 = "hello" + ", world"; // 运行时拼接，在堆上创建新对象
    String s2 = "hello, world";      // 编译期字面量，在常量池
    // s1 和 s2 是不同的对象
    ```

这些在堆上内容重复的字符串，是造成内存浪费的主要原因。`intern()` 和 G1 字符串排重正是为了解决这个问题。

---

## 优化手段一：字符串拼接 (`+` vs. `StringBuilder`)

### 结论
- **非循环中**：放心使用 `+` 进行拼接。编译器会自动优化，将其转换为 `StringBuilder`，代码简洁易读。
- **循环中**：**必须**手动使用 `StringBuilder`。在循环外创建实例，在循环内调用 `append`。

### 为什么循环中不能用 `+`？
在循环体内，`result = result + s;` 这样的代码，在**每一次循环**都会被编译器转换为 `new StringBuilder(result).append(s).toString()`。这意味着每次循环都会创建一个新的 `StringBuilder` 和一个新的 `String` 对象，产生大量临时垃圾，严重影响性能。

---

## 优化手段二：手动排重 `String.intern()`

`intern()` 方法是一个手动的、将**堆内存**中的字符串“请入”**字符串常量池**的工具。

### 工作原理
当你对一个堆上的字符串对象调用 `.intern()` 时：
1.  它会去字符串常量池中查找是否存在内容相同的字符串。
2.  如果**存在**，则返回池中对象的引用（当前堆上这个对象后续可能被 GC 回收）。
3.  如果**不存在**，则将此字符串复制到池中，然后返回池中新对象的引用。

```java
String c = new String("abc"); // 堆对象
String a = "abc";             // 常量池对象
String e = c.intern();        // 将 c 的内容与常量池关联

System.out.println(c == a);   // false
System.out.println(e == a);   // true
```

### `intern()` 的历史问题与现状
- **Java 6**：常量池位于**永久代 (PermGen)**，空间有限且不易回收。大量使用 `intern()` 极易导致 `OutOfMemoryError`。
- **Java 7/8+**：常量池被移至**堆内存**，`intern()` 变得安全。
- **缺点**：需要手动调用，代码侵入性强，不方便维护。

---

## 优化手段三：自动排重 G1 String Deduplication

这是 Java 8u20 之后 G1 垃圾回收器引入的一项强大功能，是目前**推荐**的解决方案。

### 工作原理
- **全自动**：在 GC 期间自动完成，无需修改任何业务代码。
- **后台处理**：G1 GC 会扫描堆内存，发现内容相同的字符串对象。
- **共享字符数组**：它会修改这些字符串对象的内部结构，让它们指向同一个底层的 `char[]` 数组。多余的 `char[]` 数组会被回收。

这个过程并**不会**将字符串移入常量池，而是在堆内存内部解决了数据重复的问题。

### 如何开启
此功能**默认关闭**，需要使用以下 JVM 参数启动应用：
```
-XX:+UseG1GC -XX:+UseStringDeduplication
```

## 总结对比

| 特性 | `String.intern()` | G1 字符串排重 |
| :--- | :--- | :--- |
| **工作方式** | 手动，代码中调用 | 自动，GC 后台处理 |
| **生效时机** | 调用方法的瞬间 | GC 运行时 |
| **是否改代码** | **是** | **否** |
| **适用对象** | 堆上动态创建的字符串 | 堆上动态创建的字符串 |
| **现代 Java** | 安全，但不方便 | **推荐方案**，但需手动开启 |
