# Java 核心数据结构总结

- [List (列表)](#list-列表)
    - [ArrayList](#arraylist)
    - [LinkedList](#linkedlist)
- [Set (集)](#set-集)
    - [HashSet](#hashset)
    - [TreeSet](#treeset)
- [Map (映射)](#map-映射)
    - [HashMap](#hashmap)
    - [LinkedHashMap](#linkedhashmap)
    - [TreeMap](#treemap)
    - [ConcurrentHashMap](#concurrenthashmap)
- [Queue (队列)](#queue-队列)
    - [ArrayDeque (作为栈或队列)](#arraydeque-作为栈或队列)
    - [PriorityQueue (优先队列)](#priorityqueue-优先队列)
- [其他](#其他)
    - [BitSet](#bitset)


## List (列表)

### ArrayList

-   **实现方式**: 基于**动态数组** (`Object[]`) 实现。
-   **初始化**:
    -   `new ArrayList()`: 内部数组 `elementData` 初始化为空数组 `{}`。在**第一次添加元素**时，扩容为默认容量 **10**。
    -   `new ArrayList(int initialCapacity)`: 初始化为指定容量的数组。
-   **扩容逻辑**:
    -   当元素数量将要超过当前容量时触发。
    -   新容量为旧容量的 **1.5 倍** (`oldCapacity + (oldCapacity >> 1)`)。
-   **插入调整**:
    -   尾部添加 (`add(E e)`): 时间复杂度为 **O(1)** (均摊)。
    -   指定位置插入/删除 (`add(int index, E e)`): 时间复杂度为 **O(n)**，需要批量移动 `index` 及其之后的所有元素。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE`。由于 JVM 对数组大小的限制 (通常为 `Integer.MAX_VALUE - 8`) 和内存限制，实际无法达到。在接近极限时，会抛出 `OutOfMemoryError`。

### LinkedList

-   **实现方式**: 基于**双向链表**实现。
-   **初始化**: 创建一个空链表，`first` 和 `last` 两个指针为 `null`。
-   **扩容逻辑**: 无需扩容，每次插入或删除都是节点（Node）的创建和销毁。
-   **插入调整**:
    -   头/尾插入/删除: 时间复杂度 **O(1)**，直接修改头尾指针。
    -   指定位置插入/删除: 时间复杂度 **O(n)**，需要先遍历到指定位置的节点。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE` (size() 返回 int)。实际受限于堆内存大小，在内存耗尽时会抛出 `OutOfMemoryError`。

## Set (集)

### HashSet

-   **实现方式**: 内部**基于 `HashMap`** 实现。元素存储为 `HashMap` 的 `key`，`value` 则是一个固定的 `PRESENT` 对象。不保证顺序且元素唯一。
-   **初始化**: 内部 `HashMap` 默认初始容量 **16**，负载因子 **0.75**。
-   **扩容逻辑**: 完全同 `HashMap`。当 `size > capacity * loadFactor` 时，扩容为原容量的 **2 倍**。
-   **插入调整**:
    1.  计算元素的 `hashCode()` 定位到 `HashMap` 中的桶 (bucket)。
    2.  如果桶为空，直接插入。
    3.  如果桶不为空（哈希冲突），则通过 `equals()` 方法在链表或红黑树中查找。如果不存在，则插入新元素。
-   **容量限制**: 与 `HashMap` 相同。

### TreeSet

-   **实现方式**: 内部**基于 `TreeMap` (红黑树)** 实现。元素作为 `TreeMap` 的 `key`。元素唯一且有序。
-   **特性**: 能够自动对元素进行排序，并确保元素的唯一性。非常适用于需要一个有序且无重复的集合的场景。
-   **初始化**: 创建一个空的 `TreeMap`。
-   **扩容逻辑**: 无需扩容，红黑树会动态增删节点。
-   **插入调整**:
    1.  根据元素的自然排序（实现 `Comparable`）或提供的 `Comparator` 决定插入位置。
    2.  插入新节点后，可能会通过**左旋、右旋**和**颜色翻转**来维持红黑树的自平衡。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE` (size() 返回 int)。实际受限于堆内存大小，在内存耗尽时会抛出 `OutOfMemoryError`。

## Map (映射)

### HashMap

-   **实现方式**: **数组 + 链表 / 红黑树** (JDK 8+)。
-   **初始化**: 默认初始容量 **16**，负载因子 **0.75**。
-   **扩容逻辑**:
    -   当 `size > capacity * loadFactor` 时，触发 `resize()`。
    -   新容量为旧容量的 **2 倍**，最大为 `2^30`。
    -   扩容时需要重新计算每个元素在新数组中的位置 (rehash)。
-   **插入调整**:
    1.  根据 `key` 的 `hashCode()` 计算在数组中的索引。
    2.  如果该位置无元素，直接插入。
    3.  如果该位置有元素（哈希冲突），则以链表形式存放。
    4.  当链表长度超过 **8** 且数组总容量大于 **64** 时，链表会转换为**红黑树**以优化查询性能。
-   **容量限制**: 数组容量最大为 `1 << 30` (约10亿)。元素数量理论上限为 `Integer.MAX_VALUE`。实际受限于堆内存，在内存耗尽时会抛出 `OutOfMemoryError`。

### LinkedHashMap

-   **实现方式**: 继承自 `HashMap`，额外维护一个贯穿所有条目的**双向链表**，用于记录元素的插入顺序或访问顺序。
-   **初始化**: 与 `HashMap` 相同。
-   **扩容逻辑**: 与 `HashMap` 相同。
-   **插入调整**:
    1.  `put` 过程与 `HashMap` 完全相同。
    2.  在 `HashMap` 插入成功后，会将新节点链接到双向链表的**尾部**。
    3.  如果开启了 `accessOrder=true`，`get` 操作会将访问的节点移到链表尾部，可用于实现 LRU 缓存。
-   **容量限制**: 与 `HashMap` 相同。

### TreeMap

-   **实现方式**: **红黑树**。
-   **特性**: Key 会自动保持排序状态。适用于需要对 Key 进行排序的 Map，可以方便地进行范围查找或获取有序的键集。
-   **初始化**: 创建一个空的红黑树，`root` 节点为 `null`。
-   **扩容逻辑**: 无需扩容。
-   **插入调整**: 插入后通过**左旋、右旋**和**颜色翻转**来维持红黑树的平衡，确保增删改查的时间复杂度稳定在 **O(log n)**。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE` (size() 返回 int)。实际受限于堆内存大小，在内存耗尽时会抛出 `OutOfMemoryError`。

### ConcurrentHashMap

-   **实现方式**: (JDK 8+) **`CAS` + `synchronized` + 数组 + 链表 / 红黑树**。
-   **初始化**: 默认初始容量 **16**。
-   **扩容逻辑**:
    -   **并发扩容**。当某个线程 `put` 时发现需要扩容，它会触发扩容并帮助迁移一部分数据。
    -   其他线程在访问时，如果发现正在扩容，也会加入迁移过程，多线程协同完成。整个过程对读写操作几乎无阻塞。
    -   新容量为旧容量的 **2 倍**。
-   **插入调整**:
    1.  如果目标桶为空，使用 **`CAS`** 无锁操作尝试写入节点。
    2.  如果桶不为空（哈希冲突），则对桶的头节点（链表头或树根）使用 **`synchronized`** 加锁，然后进行插入或更新。锁的粒度在桶级别，并发度高。
    3.  同样有链表长度大于8转红黑树的机制。
-   **容量限制**: 数组容量最大为 `1 << 30`。但其 size() 方法基于 long 累加，理论元素数量可超过 `Integer.MAX_VALUE`。实际受限于堆内存，在内存耗尽时会抛出 `OutOfMemoryError`。

## Queue (队列)

### ArrayDeque (作为栈或队列)

-   **实现方式**: **循环数组**。
-   **初始化**: 初始容量为 **16**。
-   **扩容逻辑**: 当数组满时，容量扩容为原容量的 **2 倍**。
-   **插入调整**:
    -   内部通过 `head` 和 `tail` 两个指针在循环数组中进行操作，实现队头队尾的高效增删。
    -   `addFirst`/`push` (作栈): `head` 指针前移。
    -   `addLast`/`offer` (作队列): `tail` 指针后移。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE`。实际受限于数组大小限制和堆内存，在内存耗尽时会抛出 `OutOfMemoryError`。

### PriorityQueue (优先队列)

-   **实现方式**: **二叉堆** (默认为小顶堆)，通过数组实现。
-   **初始化**: 初始容量 **11**。
-   **扩容逻辑**:
    -   若旧容量 < 64，则扩容为 `oldCapacity * 2 + 2`。
    -   若旧容量 >= 64，则扩容为 `oldCapacity * 1.5`。
-   **插入调整**:
    -   `offer()`: 元素添加到数组末尾，然后**上浮 (siftUp)**——与父节点比较并交换，直到满足堆的性质。O(log n)。
    -   `poll()`: 取出数组首元素（堆顶），将末尾元素移到首位，然后**下沉 (siftDown)**——与子节点比较并交换，直到重新满足堆的性质。O(log n)。
-   **容量限制**: 理论上限为 `Integer.MAX_VALUE`。实际受限于数组大小限制 (`Integer.MAX_VALUE - 8`) 和堆内存，在内存耗尽时会抛出 `OutOfMemoryError`。

## 其他

### BitSet

-   **实现方式**: **`long[]` 位数组**，每个 bit 代表一个 `true/false` 值。
-   **初始化**: `new BitSet()` 默认创建一个长度为 1 的 `long` 数组 (可表示 64 位)。
-   **扩容逻辑**: 当需要访问的 `bit` 索引超出当前 `long[]` 数组的范围时，自动扩容。新容量通常是旧容量的 **2 倍**，或至少能容纳下目标 `bit` 的大小。
-   **设置值 (set)**:
    1.  通过 `bitIndex >> 6` 计算 `long` 数组的下标 (`wordIndex`)。
    2.  通过 `1L << bitIndex` 计算 `bit` 在 `long` 值中的掩码。
    3.  使用按位或 `|` 操作将对应位置为 1。
-   **容量限制**: 可以处理的 bit 索引上限为 `Integer.MAX_VALUE`。实际受限于 `long[]` 数组的内存分配，在内存耗尽时会抛出 `OutOfMemoryError`。
