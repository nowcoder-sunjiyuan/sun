# 深入理解Java并发：乐观锁与CAS详解

## 一、 目录

- [一、 目录](#一-目录)
- [二、 乐观锁 vs 悲观锁：两种并发控制哲学](#二-乐观锁-vs-悲观锁两种并发控制哲学)
  - [2.1 悲观锁 (Pessimistic Locking)](#21-悲观锁-pessimistic-locking)
  - [2.2 乐观锁 (Optimistic Locking)](#22-乐观锁-optimistic-locking)
  - [2.3 生活中的例子](#23-生活中的例子)
  - [2.4 小结](#24-小结)
- [三、 乐观锁的核心：CAS原子操作](#三-乐观锁的核心cas原子操作)
  - [3.1 什么是CAS？](#31-什么是cas)
  - [3.2 CAS的执行流程与原子性](#32-cas的执行流程与原子性)
  - [3.3 CAS与自旋](#33-cas与自旋)
- [四、 Java中CAS的实现探秘](#四-java中cas的实现探秘)
  - [4.1 底层基石：`sun.misc.Unsafe` 类](#41-底层基石sunmiscunsafe-类)
  - [4.2 安全的API封装：`j.u.c.atomic` 原子类](#42-安全的api封装jucatomic-原子类)
  - [4.3 源码解析：`AtomicInteger` 如何工作](#43-源码解析atomicinteger-如何工作)
- [五、 CAS机制的挑战与解决方案](#五-cas机制的挑战与解决方案)
  - [5.1 经典难题：ABA问题](#51-经典难题aba问题)
  - [5.2 ABA问题的解决之道：`AtomicStampedReference`](#52-aba问题的解决之道atomicstampedreference)
  - [5.3 高竞争下的性能瓶颈：自旋开销](#53-高竞争下的性能瓶颈自旋开销)
  - [5.4 只能保证单个变量的原子性](#54-只能保证单个变量的原子性)
- [六、 高并发计数优化：`LongAdder`](#六-高并发计数优化longadder)
  - [6.1 `AtomicLong` 的局限性](#61-atomiclong-的局限性)
  - [6.2 `LongAdder` 的智慧：空间换时间的分散思想](#62-longadder-的智慧空间换时间的分散思想)
- [七、 总结：如何选择合适的锁策略](#七-总结如何选择合适的锁策略)
- [八、 CAS 深度探讨与应用实例](#八-cas-深度探讨与应用实例)
  - [8.1 ABA问题与版本号的思考](#81-aba问题与版本号的思考)
  - [8.2 `LongAdder` 的定位：专职计数器](#82-longadder-的定位专职计数器)
  - [8.3 CAS 的广泛应用](#83-cas-的广泛应用)

---

## 二、 乐观锁 vs 悲观锁：两种并发控制哲学

在并发编程中，为了保证数据在多线程访问下的准确性，我们需要一种机制来协调线程的行为。由此，诞生了两种核心的锁思想：悲观锁和乐观锁。

### 2.1 悲观锁 (Pessimistic Locking)

悲观锁对数据冲突持“悲观”态度。它总是假设最坏的情况，认为数据随时都可能被其他线程修改。因此，在每次对数据进行操作之前，都会先加锁，确保在自己操作数据期间，没有其他线程可以访问。操作完成后再释放锁。

-   **实现方式**：Java中的`synchronized`关键字和`java.util.concurrent.locks.ReentrantLock`等独占锁都是典型的悲观锁实现。
-   **优点**：实现简单，逻辑清晰。在写操作频繁、竞争激烈（“多写”）的场景下，它可以有效避免线程因冲突而不断重试带来的CPU开销。
-   **缺点**：加锁和释放锁的过程涉及线程阻塞和唤醒，会带来较大的性能开销，尤其是在竞争不激烈（“多读”）的场景下。还可能引发死锁问题。

### 2.2 乐观锁 (Optimistic Locking)

乐观锁则持“乐观”态度。它假设数据在大多数情况下不会产生冲突，所以线程可以不停地执行，无需加锁也无需等待。只是在最后提交更新的时候，才会去**验证**这个数据在自己操作期间是否被其他线程修改过。

-   **实现方式**：乐观锁通常通过“版本号机制”或“CAS算法”实现。Java中的`java.util.concurrent.atomic`包下的原子类，如`AtomicInteger`，就是基于CAS实现的乐观锁。
-   **优点**：在读操作为主、竞争不激烈的场景下，由于避免了线程阻塞的开销，性能非常高。没有死锁问题。
-   **缺点**：在写操作频繁、冲突激烈的场景下，会导致线程不断地失败和重试，反而会消耗大量CPU资源，导致性能下降。

### 2.3 生活中的例子

想象一下两人协同编辑一份在线文档：

-   **悲观锁**：编辑A在编辑前，先将文档“锁定”。此时编辑B只能只读，无法修改，直到A编辑完毕并“解锁”。
-   **乐观锁**：编辑A和B同时打开文档，各自进行修改。A先保存，服务器接受了修改，并将文档版本从v1更新到v2。随后B尝试保存，服务器发现B的修改是基于v1的，但当前最新版是v2，于是拒绝B的保存，并提示B“文档已被更新，请合并最新修改后再提交”。

### 2.4 小结

| 特性 | 悲观锁 (`synchronized`) | 乐观锁 (CAS) |
| :--- | :--- | :--- |
| **核心思想** | 总是假设有冲突，先加锁再操作 | 总是假设没冲突，直接操作，提交时验证 |
| **数据冲突处理** | 通过阻塞线程来避免冲突 | 冲突发生时，通过重试或失败来处理 |
| **性能开销** | 锁的获取与释放开销固定，涉及上下文切换 | 冲突少时性能高，冲突多时重试开销大 |
| **适用场景** | **写多读少**，竞争激烈 | **读多写少**，竞争较少 |
| **死锁** | 可能 | 不会 |

---

## 三、 乐观锁的核心：CAS原子操作

### 3.1 什么是CAS？

CAS的全称是**Compare-And-Swap（比较并交换）**。它是一种实现乐观锁的核心技术，被广泛应用于各大框架和JVM底层。

CAS的思想很简单：它是一个需要三个操作数的原子操作：
1.  **V**：要更新的内存变量值 (Variable)
2.  **E**：期望的旧值 (Expected)
3.  **N**：要写入的新值 (New)

**执行逻辑**：当且仅当内存变量V的当前值等于期望值E时，CAS才会通过原子方式用新值N来更新V的值。如果V的值不等于E，说明在当前线程准备更新的这段时间里，变量已经被其他线程修改过了，此时CAS操作会失败，当前线程放弃更新。

### 3.2 CAS的执行流程与原子性

CAS操作的原子性并非由软件实现，而是由**CPU的硬件指令**直接保证的。像Intel CPU的`cmpxchg`指令就实现了CAS的功能。这使得CAS操作即使在多核环境下也能保证其不可分割性，执行期间不会被任何其他操作打断。

**举个例子**：一个线程想把共享变量 `i` 的值从1更新为6。
1.  线程读取 `i` 的当前值为1，所以期望值 E = 1，新值 N = 6。
2.  线程执行CAS操作，比较内存中 `i` 的实际值 V 是否等于期望值 E (1)。
    -   **情况A (成功)**：V 等于 E (V == 1)。说明没有其他线程修改过 `i`。此时，CPU会自动将 `i` 的值更新为 N (6)。操作成功。
    -   **情况B (失败)**：V 不等于 E (比如 V == 5)。说明在步骤1和2之间，有其他线程已经把 `i` 的值改成了5。此时，CAS操作失败，`i` 的值不会被修改。

### 3.3 CAS与自旋

当CAS操作失败时，失败的线程并不会被挂起（阻塞），它只是被告知操作失败了。通常，程序会允许失败的线程**再次尝试**，或者放弃操作。

这种“失败后再次尝试”的机制，通常在一个循环中进行，这个循环被称为**自旋 (Spinning)**。

**伪代码示例：**
```
do {
    // 1. 读取共享变量的当前值
    expectedValue = readValue(V);
    // 2. 基于当前值计算新值
    newValue = calculateNewValue(expectedValue);
    // 3. 尝试用CAS更新，如果成功，则退出循环
} while (!CAS(V, expectedValue, newValue));
```
这种“读取-计算-CAS”的循环就是**自旋锁**的实现方式。它不断地“旋转”尝试，直到成功为止。

---

## 四、 Java中CAS的实现探秘

Java语言本身并没有直接实现CAS，而是通过JNI（Java Native Interface）调用C++代码，最终依赖操作系统和CPU指令来完成。在Java中，我们主要通过两个层级的API来接触CAS。

### 4.1 底层基石：`sun.misc.Unsafe` 类

`Unsafe`是位于`sun.misc`包下的一个特殊类，它提供了类似C++指针的低级别、不安全的操作。它是Java世界与底层硬件交互的桥梁。

`Unsafe`类提供了`compareAndSwapInt`、`compareAndSwapLong`等一系列native方法：

```java
/**
 * @param o         包含要修改field的对象
 * @param offset    对象中某field的内存偏移量
 * @param expected  期望值
 * @param update    更新值
 * @return          true | false
 */
public final native boolean compareAndSwapInt(Object o, long offset, int expected, int update);
public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);
```
这里的`offset`（偏移量）是一个关键概念。它代表一个字段在对象内存布局中的地址位置。`Unsafe`通过`对象基地址 + 偏移量`的方式，可以直接读写该字段的内存，绕过了JVM的常规访问机制。

由于`Unsafe`的强大和危险性，它不推荐被普通开发者直接使用。

### 4.2 安全的API封装：`j.u.c.atomic` 原子类

JDK为开发者提供了安全、易用的高级API，即`java.util.concurrent.atomic`包。这个包下的原子类（如`AtomicInteger`, `AtomicLong`, `AtomicReference`）是对`Unsafe`的CAS操作的美好封装。

这些类确保了对单个变量的读-改-写操作是线程安全的，且性能远高于使用`synchronized`。

### 4.3 源码解析：`AtomicInteger` 如何工作

让我们通过`AtomicInteger`的核心源码（JDK 8）来理解Java是如何运用CAS的。

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    // 1. 获取 Unsafe 实例
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    
    // 2. 获取 'value' 字段的内存偏移量
    private static final long valueOffset;
    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    // 3. 存储实际值的字段，用 volatile 保证可见性
    private volatile int value;

    // ... 构造方法等 ...

    // 4. 经典的 compareAndSet 方法，直接调用 Unsafe
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
    
    // 5. 增量操作，内部是自旋CAS
    public final int getAndAdd(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }

    public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
}
```
`unsafe.getAndAddInt`方法的实现揭示了自旋锁的本质：
```java
// Unsafe.java 中的实现
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        // 以 volatile 方式获取最新值
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta)); // CAS失败则循环重试
    return v; // 返回的是旧值
}
```
**总结**：`AtomicInteger`通过`static`代码块在类加载时就计算出`value`字段的内存偏移量`valueOffset`。之后，所有原子操作（如`compareAndSet`, `getAndAdd`）都委托给`Unsafe`实例，传入当前对象`this`、`valueOffset`以及操作的参数，从而在底层完成高效的原子操作。

---

## 五、 CAS机制的挑战与解决方案

CAS并非万能，它也有一些固有的问题。

### 5.1 经典难题：ABA问题

如果一个变量V初次读取时是A，在准备赋值时检查到它仍然是A，我们能断定它没被修改过吗？

**不能。** 在此期间，它的值可能被其他线程从A改为B，然后又改回了A。CAS检查时会误认为它从未变动，并执行更新。这就是**ABA问题**。

在大多数数值增减场景下，ABA问题无伤大雅。但在一些需要严格追踪状态变更的场景（例如，链表的头指针操作），ABA可能会导致严重错误。

### 5.2 ABA问题的解决之道：`AtomicStampedReference`

JDK 1.5之后提供了`AtomicStampedReference`类来解决ABA问题。它的思路是**引入版本号（或称为“戳”，Stamp）**。

`AtomicStampedReference`将值和版本号封装在一起。每次更新，不仅要比较值，还要比较版本号。更新成功后，会同时更新值和版本号。

```java
// expectedReference: 期望的值
// newReference: 新值
// expectedStamp: 期望的版本号
// newStamp: 新的版本号
public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp);
```
这样，即使值从A变B再变回A，版本号也已经从1变2再变3了。原始线程用期望版本号1去比较，就会失败，从而避免了ABA问题。

### 5.3 高竞争下的性能瓶颈：自旋开销

如果冲突频繁发生，线程会不断进行自旋重试，这会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的`pause`指令，可以稍稍缓解这个问题，因为它能降低CPU的功耗并提高流水线效率。

### 5.4 只能保证单个变量的原子性

CAS操作一次只能保证一个共享变量的原子性。当需要对多个变量同时进行原子操作时，CAS就无能为力了。

**解决方案**：
1.  **封装成对象**：可以将多个变量封装到一个对象中。
2.  **使用 `AtomicReference`**：通过`AtomicReference`来对这个对象实例进行CAS操作，从而实现对多个变量的“打包”原子更新。

---

## 六、 高并发计数优化：`LongAdder`

### 6.1 `AtomicLong` 的局限性

`AtomicLong`使用单个共享的`value`字段和CAS操作来进行计数。在低并发下，它性能优异。但在高并发场景下，大量线程同时对同一个`value`进行CAS操作，会导致大量的失败和自旋，性能急剧下降，成为瓶颈。

### 6.2 `LongAdder` 的智慧：空间换时间的分散思想

`LongAdder` (JDK 1.8引入) 是一个专为高并发设计的计数器，它巧妙地解决了`AtomicLong`的痛点。其核心思想是**分散热点**，将竞争压力分散到多个“槽”中。

`LongAdder`内部维护一个`base`值和一个`Cell[]`数组：
-   **无竞争时**：数据直接累加到`base`上，此时它和`AtomicLong`一样。
-   **出现竞争时**：`LongAdder`会为不同线程分配到不同的`Cell`上进行累加。每个线程只对自己`Cell`中的值进行CAS，几乎没有竞争。
-   **获取总值时 (`sum()`方法)**：将`base`和所有`Cell`中的值相加，返回一个最终的精确值。

**优点**：通过将单一的竞争点分散到多个点，极大地提高了写入（累加）的吞吐量。
**代价**：`sum()`的成本比`AtomicLong.get()`高，因为它需要遍历和累加。但在“写多读少”的计数场景下，这种“空间换时间”的策略收益巨大。

---

## 七、 总结：如何选择合适的锁策略

-   **`synchronized` (悲观锁)**:
    -   **适用**：竞争激烈、写操作占比高、临界区代码复杂的场景。它可以避免线程空转，并且能很好地处理涉及多个变量的复杂逻辑。
    -   **不适用**：竞争不激烈，性能敏感的场景。

-   **`Atomic*` (基于CAS的乐观锁)**:
    -   **适用**：竞争不激烈、读操作为主、只涉及单个变量的简单操作。
    -   **不适用**：竞争激烈时，自旋会导致CPU飙升。

-   **`LongAdder` (分段CAS)**:
    -   **适用**：高并发的计数场景，写入操作远多于读取最终结果的场景。
    -   **不适用**：需要频繁读取精确总和的场景。

理解不同锁策略的内在原理和适用场景，是在并发编程中写出高性能、高可靠性代码的关键。

---

## 八、 CAS 深度探讨与应用实例

### 8.1 ABA问题与版本号的思考

> "既然引入版本号可以解决ABA问题，为什么不直接只用版本号，而是要用 `AtomicStampedReference` 这种将值和版本号绑定的复杂结构？"

这是一个非常好的问题，它触及了CAS操作的底层本质。

答案核心在于：**CPU的CAS原子指令 (`cmpxchg`) 是直接对内存值进行操作的，而不是对一个抽象的“版本号”进行操作。**

1.  **CAS的操作对象是“值”**：CAS的全称是“比较并**交换**”。它的任务是去更新内存中的一个具体值。当你执行 `CAS(V, E, N)` 时，CPU需要去内存地址V处，读取当前的值，与你的期望值E比较，如果相等，就写入新值N。这个过程中的主角始终是那个要被修改的**值**。

2.  **原子性限制**：一个CAS指令通常只能原子性地操作一个内存单元（比如一个64位的`long`)。如果你把数据的值和版本号存放在两个不同的内存地址，你无法用一个CAS指令同时原子地更新它们。这将需要两次CAS操作，而在这两次操作之间，其他线程可能已经修改了数据，这就破坏了原子性。

3.  <mark>**`AtomicStampedReference` 的角色**：`AtomicStampedReference` 的巧妙之处就在于它将“值（引用）”和“版本号（stamp）”**打包**成一个逻辑单元，并通过内部机制（可能是在64位系统中将一个32位引用和一个32位整数打包成一个64位`long`）让CAS指令可以对这个“打包后”的整体进行原子操作。这样，`compareAndSet` 方法在比较时，既比较了值的引用，也比较了版本号，确保了两者都符合预期时，才原子地更新“打包”后的新值（包含新的引用和新的版本号）</mark>。

**总结**：我们不是“不直接用版本号”，而是必须将“版本号”和我们要操作的“值”捆绑在一起，作为一个整体，交由底层的CAS指令进行原子地“比较和交换”。`AtomicStampedReference` 正是实现了这种捆绑的、符合CAS操作模式的工具。

### 8.2 `LongAdder` 的定位：专职计数器

> "`LongAdder` 的作用只是计数器吗？"

是的，可以非常肯定地说，`LongAdder` 被设计出来的**唯一目的**就是作为高并发场景下的高性能**计数器**。

它的API设计也反映了这一点，只提供了 `add()`、`increment()`、`sum()` 等与数值累加相关的操作。你无法像使用`AtomicLong`那样，用 `compareAndSet()` 方法去原子地设置一个你期望的值。

-   **`AtomicLong`**：是一个通用的原子长整型，它既能用于计数，也能作为一个需要原子更新的“状态标志”或“配置值”。
-   **`LongAdder`**：是一个专用的计数器。它通过内部维护一个`base`值和一个`Cell`数组，将并发更新的压力分散，实现了极高的写入吞吐量。但代价是读取总和 (`sum()`) 的操作相对较重，并且不支持通用的CAS操作。

因此，在选择时：
-   如果你的场景是高并发的指标统计、计数等，**写多读少**，`LongAdder` 是不二之-   如果你需要一个通用的原子变量，并且可能需要 `compareAndSet` 这样的操作，或者**读操作非常频繁**，那么 `AtomicLong` 更合适。

### 8.3 CAS 的广泛应用

除了上文中提到的 `Atomic*` 原子类，CAS作为一种无锁编程的基石，其思想和应用渗透在各个角落。

你提到的两个例子非常经典：
-   **JVM分配对象内存**：当多个线程需要从Eden区分配内存时，JVM使用CAS来移动“指针”，为线程划分出线程本地分配缓冲（TLAB），避免了加锁。
-   **`synchronized` 轻量级锁**：在无竞争或低竞争时，JVM会使用轻量级锁，通过CAS将对象头中的Mark Word指向持有锁的线程栈，避免了调用操作系统的重量级互斥量。

除此之外，还有很多应用场景：

1.  **并发容器**：`java.util.concurrent` 包下的许多无锁容器都依赖于CAS。`ConcurrentLinkedQueue` 就是一个经典例子，它在入队和出队操作时，通过CAS来原子地更新队列的头（`head`）和尾（`tail`）节点的指针，从而实现了高效的无锁并发。我们将在下面详细对比。

2.  **异步编程框架**：你可能怀疑，一个任务完成后，为什么还会有并发修改它的状态。说得很对，一个已完成的 `CompletableFuture` 的状态是不可变的。CAS解决的不是完成后的修改，而是**多个事件并发地争抢“完成权”**的场景。

    想一下一个`Future`可能被如何结束：
    *   <mark>正常任务执行完毕，返回结果</mark>。
    *   <mark>一个外部的超时监控线程决定让它因超时而失败</mark>。
    *   <mark>用户线程调用 `cancel()` 来取消它。</mark>

    这三个事件完全可能同时发生。`CompletableFuture` 内部就利用CAS来原子地更新状态，确保这三个事件中只有一个能成功，从而保证 `Future` 的最终状态只有一次被设定。

#### 8.3.1 并发容器 vs 普通容器

你问到并发容器和普通容器的区别，以及普通容器是否无法支持并发。是的，`java.util` 包中的集合类（如 `ArrayList`, `HashMap`）都是**非线程安全**的。在多线程下对它们进行读写，会导致数据错乱、`ConcurrentModificationException` 等严重问题。

`java.util.concurrent` 包则提供了它们的线程安全版本，性能经过高度优化。

| 普通容器 (`java.util`) | 并发容器 (`java.util.concurrent`) | 主要特点 |
| :--- | :--- | :--- |
| `HashMap` | `ConcurrentHashMap` | 内部通过分段锁或CAS机制，支持大规模高并发的读写。 |
| `ArrayList` | `CopyOnWriteArrayList` | “写时复制”容器。所有读操作完全无锁，但每次写操作都会拷贝一份新数组，成本高。适用于“读远大于写”的场景。 |
| `LinkedList` (用作队列) | `ConcurrentLinkedQueue` | 基于CAS实现的无锁队列，性能极高，是实现高吞吐量生产者-消费者模式的利器。 |
| (无直接对应) | `ArrayBlockingQueue`, `LinkedBlockingQueue` | 阻塞队列。当队列满或空时，相关操作会阻塞线程，是标准的生产者-消费者模型工具。 |

#### 8.3.2 业务系统的乐观锁：权益扣点

你提到的“权益扣点”场景比之前的HR例子好得多，也更普遍。这是一个在真实业务中应用乐观锁（CAS思想）的绝佳范例。

**场景：用户使用积分扣减**

假设一个用户有1000点权益积分，他想用50点来查看一份简历。如果系统并发量大，用户可能会因为网络延迟而双击按钮，导致两个请求几乎同时到达服务器。

**竞态条件下的问题：**
1.  请求A读到用户有1000点。
2.  请求B也读到用户有1000点。
3.  请求A执行扣点逻辑（1000 - 50 = 950），将用户积分更新为950。
4.  请求B也执行扣点逻辑（1000 - 50 = 950），也将用户积分更新为950。

**结果**：系统响应了两次请求，消耗了两次资源（比如都让用户看到了简历），但只扣了用户一次的钱。这会导致业务逻辑错误和公司损失。

**使用乐观锁（数据库中的CAS）解决：**

我们在 `user_equity` 表中增加一个 `version` 字段，默认为0。

1.  **读取数据**：两个请求同时读到用户数据为 `(points: 1000, version: 25)`。应用代码检查 `points >= 50`，条件满足。
2.  **尝试更新**：两个请求都基于自己读取到的版本号 `25` 去尝试更新。
    ```sql
    UPDATE user_equity
    SET points = 950, version = 26
    WHERE user_id = 'some_user_id' AND version = 25;
    ```
3.  **最终结果**：
    *   **请求A (先到达)**：它的`UPDATE`语句执行时，`WHERE`条件（`version = 25`）成立，更新成功。数据库返回“1 row affected”。此时数据库中的数据变为 `(points: 950, version: 26)`。
    *   **请求B (后到达)**：当它的`UPDATE`语句执行时，数据库中的`version`已经是`26`了，所以`WHERE`条件（`version = 25`）不成立。更新失败，数据库返回“0 rows affected”。

4.  **应用层处理**：请求B的应用代码收到了“0 rows affected”的结果，就明白了在自己操作期间，数据已经被其他线程修改了。此时它可以友好地提示用户“操作正在处理中，请勿重复点击”，或者如果业务允许，可以重试整个“读-计算-写”流程。

这个方案完全避免了使用重量级的数据库排他锁（`SELECT ... FOR UPDATE`），在保证数据绝对一致性的前提下，维持了系统的高并发处理能力。
