# 深入理解Java并发：synchronized关键字详解

## 一、 目录

- [一、 目录](#一-目录)
- [二、 synchronized是什么？为什么需要它？](#二-synchronized是什么为什么需要它)
  - [2.1 核心问题：线程安全](#21-核心问题线程安全)
  - [2.2 synchronized的角色：同步锁](#22-synchronized的角色同步锁)
- [三、 synchronized的三种使用方式](#三-synchronized的三种使用方式)
  - [3.1 修饰实例方法：锁住对象实例](#31-修饰实例方法锁住对象实例)
  - [3.2 修饰静态方法：锁住类对象](#32-修饰静态方法锁住类对象)
  - [3.3 修饰代码块：精准控制锁的范围](#33-修饰代码块精准控制锁的范围)
  - [3.4 深入辨析：静态方法锁 vs 实例方法锁](#34-深入辨析静态方法锁-vs-实例方法锁)
  - [3.5 特别注意：不要用字符串常量作为锁对象](#35-特别注意不要用字符串常量作为锁对象)
  - [3.6 构造方法能否使用synchronized？](#36-构造方法能否使用synchronized)
- [四、 synchronized的底层原理探秘](#四-synchronized的底层原理探秘)
  - [4.1 Java对象头与Monitor](#41-java对象头与monitor)
  - [4.1.1 Monitor的内部结构与工作原理](#411-monitor的内部结构与工作原理)
  - [4.2 同步代码块的实现：monitorenter与monitorexit](#42-同步代码块的实现monitorenter与monitorexit)
  - [4.3 同步方法的实现：ACC_SYNCHRONIZED标志](#43-同步方法的实现acc_synchronized标志)
  - [4.4 总结：本质都是获取Monitor](#44-总结本质都是获取monitor)
- [五、 JDK 1.6后的锁优化：锁升级之路](#五-jdk-16后的锁优化锁升级之路)
  - [5.1 锁的四种状态](#51-锁的四种状态)
  - [5.2 锁升级过程详解](#52-锁升级过程详解)
    - [5.2.1 偏向锁 (Biased Locking)](#521-偏向锁-biased-locking)
    - [5.2.2 轻量级锁 (Lightweight Locking)](#522-轻量级锁-lightweight-locking)
    - [5.2.3 重量级锁 (Heavyweight Locking)](#523-重量级锁-heavyweight-locking)
  - [5.3 其他优化：自旋锁、锁消除与锁粗化](#53-其他优化自旋锁锁消除与锁粗化)
- [六、 偏向锁的废弃：历史的进程](#六-偏向锁的废弃历史的进程)

---

## 二、 synchronized是什么？为什么需要它？

### 2.1 核心问题：线程安全

在多线程编程中，最核心、最棘手的问题莫过于**线程安全**。当多个线程同时访问并修改同一个共享资源时，如果没有适当的同步措施，就可能导致数据错乱、状态不一致等问题。

**举个例子：银行取款**

假设一个银行账户有1000元，线程A和线程B同时取款1000元。理想情况下，只有一个线程能成功，账户余额变为0。但如果没有同步，可能会发生以下情况：

1.  线程A读取余额，得到1000。
2.  线程B也读取余额，得到1000。
3.  线程A执行扣款操作，将余额更新为0。
4.  线程B也执行扣款操作，再次将余额更新为0。

最终结果看似正确，但银行实际上损失了1000元。这就是典型的线程安全问题。

### 2.2 synchronized的角色：同步锁

`synchronized`是Java提供的一个原生关键字，它的核心作用就是提供一种**互斥锁（Mutex Lock）**的机制，来解决上述的线程安全问题。它可以保证：

-   **原子性 (Atomicity)**：被`synchronized`修饰的代码块或方法，在同一时刻只能被一个线程执行。一个线程在执行时，其他试图进入的线程都将被阻塞，直到当前线程执行完毕。
-   **可见性 (Visibility)**：当一个线程释放锁时，它对共享变量所做的修改，会立即刷新到主内存中，确保其他线程在获取锁后能够看到最新的值。
-   **有序性 (Ordering)**：`synchronized`内部的指令执行顺序在单个线程内看起来是有序的，并且可以防止指令重排序对多线程语义的破坏。

简单来说，`synchronized`就像给一个房间（共享资源）上了一把锁，只有一个持有钥匙（获取锁）的线程能进去办事，办完事出来后把钥匙交给下一个等待的线程。

---

## 三、 synchronized的三种使用方式

`synchronized`提供了灵活的使用方式，可以根据需要锁定不同的目标，从而控制同步的粒度。

### 3.1 修饰实例方法：锁住对象实例

当`synchronized`修饰一个非静态的实例方法时，它锁定的对象是**当前方法所属的对象实例 (this)**。

```java
public class BankAccount {
    private int balance;

    public synchronized void withdraw(int amount) {
        // 这里的代码在任意时刻只能被一个线程执行
        // 锁是 this，即 BankAccount 的实例对象
        if (balance >= amount) {
            balance -= amount;
        }
    }
}
```

-   **效果**：如果`account1`和`account2`是`BankAccount`的两个不同实例，那么一个线程调用`account1.withdraw()`，另一个线程调用`account2.withdraw()`，它们之间是**互不影响**的，因为它们获取的是两把不同的锁（`account1`和`account2`）。但如果两个线程**同时**调用`account1.withdraw()`，那么其中一个线程必须等待另一个执行完毕。

### 3.2 修饰静态方法：锁住类对象

当`synchronized`修饰一个静态方法时，它锁定的不是某个实例，而是**这个类本身对应的Class对象**。

```java
public class BankService {
    private static int totalTransactions = 0;

    public static synchronized void incrementTransaction() {
        // 这里的锁是 BankService.class 这个对象
        totalTransactions++;
    }
}
```

-   **效果**：因为一个类在JVM中只有一个Class对象，所以无论有多少个`BankService`的实例，或者甚至没有实例，当多个线程调用`BankService.incrementTransaction()`时，它们竞争的都是**同一把锁**。这会保证对静态资源`totalTransactions`的修改是线程安全的。

### 3.3 修饰代码块：精准控制锁的范围

这是最灵活的方式，可以显式指定**锁定的对象**，并且可以最小化同步代码的范围，提高性能。

```java
public class MyService {
    private final Object lock = new Object();

    public void performAction() {
        // ... 其他非同步的业务代码 ...

        synchronized (lock) { // 或者 synchronized(this)
            // 需要同步执行的核心代码
        }

        // ... 其他非同步的业务代码 ...
    }

    public static void performStaticAction() {
        synchronized (MyService.class) {
            // 针对静态资源同步
        }
    }
}
```

-   `synchronized(this)`：等价于修饰实例方法。
-   `synchronized(MyService.class)`：等价于修饰静态方法。
-   `synchronized(someObject)`：锁定括号内指定的任何对象。这提供了更细粒度的锁控制。

### 3.4 深入辨析：静态方法锁 vs 实例方法锁

一个常见的误区是混淆这两种锁。请记住：**它们是两把完全不同的锁！**

-   **实例方法锁**：锁的是 `new` 出来的**对象实例**。
-   **静态方法锁**：锁的是类的 **`Class` 对象**。

这意味着，一个线程调用一个对象的**静态synchronized方法**，而另一个线程调用这个对象的**非静态synchronized方法**，两者是**不会互斥**的，因为它们尝试获取的锁不同。

### 3.5 特别注意：不要用字符串常量作为锁对象

应避免使用`synchronized("some_string")`。因为JVM中存在字符串常量池，所有内容相同的字符串字面量都会指向常量池中的同一个对象。这会导致在一个完全不相关的类中，如果也使用了`synchronized("some_string")`，它们会意外地竞争同一把锁，导致难以排查的死锁或性能问题。

### 3.6 构造方法能否使用synchronized？

**不能。** 构造方法本身在设计上就是线程安全的。在JVM内部，对象的创建过程是原子性的，一个线程在完成一个对象的构造之前，其他线程是无法看到这个“半成品”对象的。但是，如果在构造方法内部启动了新的线程，或者操作了共享的静态资源，那么依然需要对这些操作进行同步控制，例如在构造方法内部使用`synchronized`代码块。

---

## 四、 synchronized的底层原理探秘

`synchronized`的魔力源于JVM层面的实现。理解其底层机制，有助于我们更深刻地认识Java的并发模型。

### 4.1 Java对象头与Monitor

在HotSpot虚拟机中，每个Java对象都有一个**对象头（Object Header）**。在64位JVM中，对象头通常占用12或16个字节，它由两部分组成：

1.  **Mark Word (标记字段)**：占用8个字节（64位）。这是实现`synchronized`锁以及存储对象运行时状态的核心。它是一个高度复用的数据结构，根据对象的锁状态，存储着不同的信息，如哈希码、GC分代年龄、锁状态标志、持有锁的线程ID、指向锁记录的指针等。
2.  **Klass Pointer (类型指针)**：占用4个字节（在开启指针压缩的情况下）。它指向方法区中该对象对应的类元数据。

`synchronized`的锁信息就存储在对象的Mark Word中。当锁升级为重量级锁时，Mark Word会指向一个叫做**对象监视器（Monitor）**的内部结构。

**Mark Word 在不同锁状态下的结构 (64位虚拟机):**

| 锁状态 | 锁标志位 (后3位) | 存储内容 (从高位到低位) |
| :--- | :--- | :--- |
| **无锁** | `001` (biased_lock=0, lock=01) | `unused(25)` `identity_hashcode(31)` `unused(1)` `age(4)` `0` `01` |
| **偏向锁** | `101` (biased_lock=1, lock=01) | `thread_id(54)` `epoch(2)` `unused(1)` `age(4)` `1` `01` |
| **轻量级锁**| `00` (lock=00) | `ptr_to_lock_record(62)` `00` |
| **重量级锁**| `10` (lock=10) | `ptr_to_heavyweight_monitor(62)` `10` |
| **GC标记** | `11` (lock=11) | `(空)` |

这个表格清晰地展示了JVM是如何通过最后3个比特位来区分四种锁状态的。

### 4.1.1 Monitor的内部结构与工作原理

当锁膨胀为重量级锁时，JVM会为该对象关联一个C++实现的`ObjectMonitor`对象。<mark>并非每个Java对象一出生就拥有一个Monitor，而是在需要时（即首次要进入重量级锁状态时）才创建和关联。</mark>这个Monitor是`synchronized`重量级锁的核心，它负责管理线程的排队、阻塞和唤醒。

`ObjectMonitor`内部有几个关键的数据结构：

-   `_owner`：一个指针，指向当前持有该Monitor的线程。
-   `_recursions`：一个计数器，记录线程重入锁的次数。
-   `_EntryList`：一个**竞争队列**。所有尝试获取锁失败的线程，都会被封装成节点放入这个队列中，并进入**阻塞（Blocked）**状态。
-   `_WaitSet`：一个**等待队列**。当持有锁的线程调用了对象的`wait()`方法后，该线程会释放锁，并被放入这个队列中，进入**等待（Waiting）**状态。

**`_EntryList` 和 `_WaitSet` 的关键区别：**

> **`_WaitSet` 对于synchronized来说是不是没用？？？synchronized是不是只是阻塞线程进入_EntryList呢？？？**
>
> 你的问题非常精准！
> - 对于**纯粹的锁竞争**场景，`synchronized`确实只使用`_EntryList`。当一个线程无法获取锁时，它就会被放入`_EntryList`中阻塞。
> - <mark>`_WaitSet`是为`Object.wait()`/`notify()`/`notifyAll()`这套**线程间通信机制**服务的。Java规范规定，这三个方法必须在`synchronized`代码块或方法中调用。所以，`_WaitSet`虽然不直接参与锁竞争，但它与`synchronized`是紧密绑定的“组合功能”。一个线程调用`wait()`会主动释放锁并进入`_WaitSet`</mark>；当它被`notify()`唤醒后，并不能马上执行，而是会被移动到`_EntryList`中，重新参与锁的竞争。

**底层系统调用：**

`Monitor`的线程阻塞和唤醒能力，并非由JVM凭空实现，而是依赖于底层**操作系统**提供的功能。这个过程通常通过**系统调用**来完成，例如Linux下的`futex`（Fast Userspace Mutex）或传统的**互斥锁（Mutex Lock）**。系统调用会触发昂贵的**用户态到内核态的切换**，这正是重量级锁“重”的根源。

> **线程状态辨析：阻塞 vs 等待**
>
> `_EntryList`中的线程，因为抢锁失败而被动挂起，它们的状态是**BLOCKED**。CPU调度器不会给它们分配时间片。当锁被释放时，操作系统会从`_EntryList`中唤醒一个线程，使其变为RUNNABLE状态。
> `_WaitSet`中的线程，是自己调用`wait()`主动放弃CPU的，它们的状态是**WAITING**或**TIMED_WAITING**。它们不能被锁的释放所唤醒，必须等待其他线程调用`notify()`或`notifyAll()`来显式唤醒。唤醒后，它们也需要先进入`_EntryList`去竞争锁。

### 4.2 同步代码块的实现：monitorenter与monitorexit

当我们使用`synchronized`代码块时，Java编译器会在同步块的开始和结束位置，生成两条特殊的字节码指令：`monitorenter` 和 `monitorexit`。

**示例代码:**
```java
public class SyncDemo {
    public void method() {
        synchronized (this) {
            System.out.println("Hello");
        }
    }
}
```

**编译后的字节码 (示意):**
```
// ...
aload_0       // 将 this 压入操作数栈 (作为锁对象)
dup           // 复制一份 this (用于 monitorexit)
monitorenter  // 尝试获取锁
// --- 同步代码块开始 ---
getstatic     #2 // System.out
ldc           #3 // "Hello"
invokevirtual #4 // println
// --- 同步代码块结束 ---
aload_0       // 将之前复制的 this 压入栈
monitorexit   // 释放锁
goto          12
// 异常处理部分
astore_1      // 存储异常
aload_0       // 将 this 压入栈
monitorexit   // 异常情况下也要释放锁
aload_1
athrow
// ...
```

-   **`monitorenter`**：当线程执行到这条指令时，它会尝试获取锁对象关联的Monitor的所有权。
    -   如果获取成功（Monitor的计数器为0），则计数器加1，该线程成为锁的持有者。
    -   如果该线程已经持有该锁，则计数器再次加1（这体现了`synchronized`是**可重入锁**）。
    -   如果锁被其他线程持有，则当前线程阻塞，直到锁被释放。
-   **`monitorexit`**：当线程执行完同步代码，执行这条指令时，会将Monitor的计数器减1。当计数器变为0时，锁被完全释放，其他等待的线程可以开始竞争锁。

你会发现字节码中有**两个`monitorexit`**。这是为了保证即使同步代码块中发生异常，锁也一定能被释放，避免死锁。

### 4.3 同步方法的实现：ACC_SYNCHRONIZED标志

对于`synchronized`修饰的方法，实现方式略有不同。它不是通过字节码指令，而是通过在方法的访问标志（access flags）中添加一个`ACC_SYNCHRONIZED`标志。

当JVM在调用一个方法时，会检查它是否有`ACC_SYNCHRONIZED`标志。
-   如果有，那么在执行方法体之前，执行线程必须先成功获取该方法所属对象（实例方法）或类对象（静态方法）的Monitor。
-   方法执行完毕后（无论是正常返回还是异常退出），再自动释放Monitor。

### 4.4 总结：本质都是获取Monitor

无论是`monitorenter`/`monitorexit`指令，还是`ACC_SYNCHRONIZED`标志，其底层核心逻辑是统一的：**对对象监视器Monitor的获取与释放**。

---

## 五、 JDK 1.6后的锁优化：锁升级之路

在Java早期版本，`synchronized`直接依赖于操作系统底层的`Mutex Lock`，线程的阻塞和唤醒需要在用户态和内核态之间切换，成本非常高，因此被称为**重量级锁**。

从JDK 1.6开始，HotSpot虚拟机团队对`synchronized`进行了大量优化，引入了**锁升级**的概念，目的是在不同竞争烈度下，采用不同成本的锁策略，以提升性能。

### 5.1 锁的四种状态

锁的状态一共有四种，级别从低到高依次是：
1.  **无锁状态**
2.  **偏向锁状态**
3.  **轻量级锁状态**
4.  **重量级锁状态**

**核心思想**：锁的状态会随着竞争情况的加剧而**单向升级（不能降级）**，以适应不同的场景。

### 5.2 锁升级过程详解

#### 5.2.1 偏向锁 (Biased Locking)

-   **动机**：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得。
-   **原理**：当一个线程第一次获取锁时，JVM会将对象头中的标志位设为“偏向模式”，并用CAS操作将获取到该锁的线程ID记录在对象的Mark Word中。此后，只要是这个线程再次进入该同步块，就不再需要进行任何同步操作，直接通过检查Mark Word中的线程ID即可，极大地降低了获取锁的代价。
-   **升级时机**：当有**另一个**线程尝试获取这个偏向锁时，偏向模式宣告结束。JVM会撤销偏向锁，并根据情况将锁升级为轻量级锁。

#### 5.2.2 轻量级锁 (Lightweight Locking)

-   **动机**：当存在锁竞争，但竞争通常在很短的时间内结束，线程持有锁的时间不长。
-   **原理**：线程在获取锁时，<mark>JVM会在当前线程的栈帧中创建一块名为“锁记录（Lock Record）”的空间，用于拷贝和暂存对象Mark Word的副本（这其中就包含了对象的哈希码、GC分代年龄等信息）。然后，JVM尝试使用CAS操作，将对象的Mark Word更新为指向这个锁记录的指针</mark>。
    -   如果CAS成功，该线程就获得了锁。
    -   如果CAS失败，说明已存在竞争。当前线程会**自旋**（执行一个忙循环，不放弃CPU）一小段时间，尝试再次获取锁。
-   **优点**：避免了使用操作系统互斥量所带来的性能开销。
-   **升级时机**：如果自旋一定次数后（或有其他线程也在自旋），仍然无法获取锁，说明竞争已经比较激烈了，轻量级锁就会膨胀为重量级锁。

#### 5.2.3 重量级锁 (Heavyweight Locking)

-   **原理**：这就是传统的锁实现方式。对象的Mark Word会被修改为指向一个重量级锁的指针，这个锁即是与对象关联的Monitor。所有获取锁失败的线程都会被阻塞，进入Monitor的等待队列，等待操作系统进行调度和唤醒。
-   **缺点**：性能开销最大，涉及用户态与内核态的切换。

### 5.3 其他优化：自旋锁、锁消除与锁粗化

-   **自旋锁与适应性自旋**：轻量级锁失败后，不立即阻塞，而是“自旋”等待。适应性自旋则更智能，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
-   **锁消除 (Lock Elision)**：JIT编译器在运行时，如果能通过逃逸分析证明一个对象不会被其他线程访问（即它是线程私有的），那么就会大胆地消除掉这个对象上的所有同步锁。
-   **锁粗化 (Lock Coarsening)**：如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那么JIT编译器会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

---

## 六、 偏向锁的废弃：历史的进程

尽管偏向锁在特定场景下能带来性能提升，但它也给JVM的实现带来了巨大的复杂性。随着技术的发展，其收益变得不再那么明显：
1.  **现代并发库的兴起**：像`ConcurrentHashMap`等高性能并发容器的出现，减少了对早期同步集合（如`Hashtable`）的依赖，而这些集合是偏向锁的主要受益者。
2.  **维护成本高昂**：偏向锁的撤销过程相当复杂，需要进入全局安全点（Stop-the-World），在多线程竞争频繁的场景下反而会成为性能瓶颈。
3.  **收益有限**：其性能提升主要体现在单线程反复获取锁的场景，一旦出现竞争，撤销的开销可能会抵消掉之前的收益。

基于这些原因，OpenJDK社区做出了决定：
-   **JDK 15**：默认关闭偏向锁。
-   **JDK 18**：彻底废弃并移除偏向锁。

这标志着Java并发技术在不断演进，通过简化内部机制，来适应现代多核硬件和更复杂的并发编程模型。
